{
  "_id": "contracts_mdm_processor",
  "name": "contracts_mdm",
  "type": "processor",
  "refType": "app",
  "refTypeId": "12325a98-a959-4939-9005-4158d136afcd",
  "snippet": "var moment = require('moment');\r\n    const request = require('request').defaults({\r\n      headers: {\r\n        requestid: req.headers.requestid\r\n      }\r\n    });\r\n    req.body.mdmProcessorServiceKey = JSON.parse(req.body.mdmProcessorServiceKey);\r\n    var serviceKey = req.body.mdmProcessorServiceKey[0].serviceKey;\r\n\r\n    const getRequestBody = url => ({\r\n      method: 'GET',\r\n      url,\r\n      headers: {\r\n        Authorization: req.headers.authorization,\r\n        'X-TenantID': req.headers['x-tenantid']\r\n      },\r\n      json: true\r\n    });\r\n\r\n    const getRequestBodyPost = (url, obj) => ({\r\n      method: 'GET',\r\n      url,\r\n      headers: {\r\n        Authorization: req.headers.authorization,\r\n        'X-TenantID': req.headers['x-tenantid']\r\n      },\r\n      json: true,\r\n      body: obj\r\n    });\r\n\r\n    function getData(requestBody) {\r\n      return new Promise(function(resolve, reject) {\r\n        request(requestBody, function(err, response, body) {\r\n          if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n            resolve(body);\r\n          } else {\r\n            reject(body);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    function prepareMdmCollection(platformres) {\r\n      let mdmCollection = {\r\n        poolpricekey: {},\r\n        contractKey: {},\r\n        priceKey: {},\r\n        quantityKey: {},\r\n        shipmentStartKey: {},\r\n        shipmentEndKey: {},\r\n        multigradeKey: {},\r\n        priceTypeKey: {},\r\n        spreadKey: {},\r\n        cashPriceKey: {},\r\n        approvalKey: {},\r\n        cashClientCodeKey: {},\r\n        poolClientCodeKey: {},\r\n        cashBpRefNumberKey: {},\r\n        poolBpRefNumberKey: {},\r\n        pricingoptionKey: {},\r\n        marketTypeKey: {},\r\n        isInternalBpCashKey: {},\r\n        isInternalBpPoolKey: {}\r\n      };\r\n\r\n      function getOption(serviceKey, key, dependent, dependent1 = null) {\r\n        if (!mdmCollection[serviceKey][key]) {\r\n          mdmCollection[serviceKey][key] = {\r\n            [dependent]: true\r\n          };\r\n          if (dependent1 != null) {\r\n            mdmCollection[serviceKey][key] = {\r\n              ...mdmCollection[serviceKey][key],\r\n              [dependent1]: true\r\n            };\r\n          }\r\n        } else {\r\n          if (!mdmCollection[serviceKey][key][dependent]) {\r\n            mdmCollection[serviceKey][key] = {\r\n              ...mdmCollection[serviceKey][key],\r\n              [dependent]: true\r\n            };\r\n          }\r\n          if (dependent1 != null) {\r\n            if (!mdmCollection[serviceKey][key][dependent1]) {\r\n              mdmCollection[serviceKey][key] = {\r\n                ...mdmCollection[serviceKey][key],\r\n                [dependent1]: true\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      platformres.forEach(item => {\r\n        for (let key in item) {\r\n          key === 'pricingOption' && getOption('poolpricekey', item[key], item['price']);\r\n          key === 'bpName' && getOption('cashPriceKey', item[key], item['price']);\r\n          key === 'corporate' && getOption('contractKey', item[key], item['contractRefNo']);\r\n          key === 'contractRefNo' && getOption('priceKey', item[key], item['contractPrice']);\r\n          key === 'contractRefNo' && getOption('quantityKey', item[key], item['itemOpenQuantityInBase']);\r\n          key === 'contractRefNo' && getOption('shipmentStartKey', item[key], item['shipmentPeriodFrom']);\r\n          key === 'contractRefNo' && getOption('shipmentEndKey', item[key], item['shipmentPeriodTo']);\r\n          key === 'contractRefNo' && getOption('multigradeKey', item[key], item['isMultiGrade']);\r\n          key === 'contractRefNo' && getOption('priceTypeKey', item[key], item['priceType']);\r\n          key === 'contractRefNo' && getOption('spreadKey', item[key], item['spread']);\r\n          key === 'contractRefNo' && getOption('approvalKey', item[key], item['approvalStatus']);\r\n          key === 'bpName' && getOption('cashClientCodeKey', item[key], item['bpExternalCode']);\r\n          key === 'pricingOption' && getOption('poolClientCodeKey', item[key], item['bpExternalCode']);\r\n          key === 'bpName' && getOption('cashBpRefNumberKey', item[key], item['bpRefNo']);\r\n          key === 'pricingOption' && getOption('poolBpRefNumberKey', item[key], item['bpRefNo']);\r\n          key === 'bpName' && getOption('isInternalBpCashKey', item[key], item['isInternalBp']);\r\n          key === 'pricingOption' && getOption('isInternalBpPoolKey', item[key], item['isInternalBp']);\r\n        }\r\n      });\r\n\r\n      return mdmCollection;\r\n    }\r\n\r\n    let wht;\r\n    if (req.body.selectedData.ticketlistingcomposite.hasOwnProperty('ticketlistingwarehoused')) {\r\n      wht = req.body.selectedData.ticketlistingcomposite.ticketlistingwarehoused;\r\n    } else {\r\n      let temp = req.body.selectedData.ticketlistingcomposite;\r\n      wht = [];\r\n      wht.push(temp);\r\n    }\r\n    let pro = wht[0].product;\r\n    let seas = wht[0].cropYear;\r\n\r\n    const grades = [];\r\n    const locations = [];\r\n    let cashPoolGrades = [];\r\n\r\n    for (let i = 0; i < wht.length; i++) {\r\n      grades.push(wht[i].quality);\r\n      cashPoolGrades.push(wht[i].quality);\r\n      locations.push(wht[i].bulkHandler);\r\n    }\r\n\r\n    if (!cashPoolGrades.every(item => item === cashPoolGrades[0])) {\r\n      cashPoolGrades = [];\r\n    }\r\n\r\n    let cashObj = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${pro}`\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'in',\r\n            value: cashPoolGrades\r\n          },\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: `${seas}`\r\n          },\r\n          {\r\n            fieldName: 'site',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${wht[0].location}`\r\n          },\r\n          {\r\n            fieldName: 'status',\r\n            operator: 'ne',\r\n            value: 'Expired'\r\n          },\r\n          {\r\n            fieldName: 'marketType',\r\n            operator: 'eqCaseInsensitive',\r\n            value: 'Cash'\r\n          },\r\n          {\r\n            fieldName: 'startDateTime',\r\n            operator: 'lte',\r\n            value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n          },\r\n          {\r\n            fieldName: 'endDateTime',\r\n            operator: 'gte',\r\n            value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n          }\r\n        ]\r\n      },\r\n      distinctColumns: ['bpName']\r\n    };\r\n\r\n    let poolObj = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${pro}`\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'in',\r\n            value: cashPoolGrades\r\n          },\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: `${seas}`\r\n          },\r\n          {\r\n            fieldName: 'site',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${wht[0].location}`\r\n          },\r\n          {\r\n            fieldName: 'status',\r\n            operator: 'ne',\r\n            value: 'Expired'\r\n          },\r\n          {\r\n            fieldName: 'marketType',\r\n            operator: 'eqCaseInsensitive',\r\n            value: 'Pool'\r\n          },\r\n          {\r\n            fieldName: 'startDateTime',\r\n            operator: 'lte',\r\n            value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n          },\r\n          {\r\n            fieldName: 'endDateTime',\r\n            operator: 'gte',\r\n            value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n          }\r\n        ]\r\n      },\r\n      distinctColumns: ['bpName']\r\n    };\r\n\r\n    let allCashObj = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${pro}`\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'in',\r\n            value: cashPoolGrades\r\n          },\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: `${seas}`\r\n          },\r\n          {\r\n            fieldName: 'site',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${wht[0].location}`\r\n          },\r\n          {\r\n            fieldName: 'status',\r\n            operator: 'ne',\r\n            value: 'Expired'\r\n          },\r\n          {\r\n            fieldName: 'marketType',\r\n            operator: 'eqCaseInsensitive',\r\n            value: 'Cash'\r\n          },\r\n          {\r\n            fieldName: 'startDateTime',\r\n            operator: 'lte',\r\n            value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n          },\r\n          {\r\n            fieldName: 'endDateTime',\r\n            operator: 'gte',\r\n            value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n          }\r\n        ]\r\n      }\r\n    };\r\n\r\n    let allPoolObj = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${pro}`\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'in',\r\n            value: cashPoolGrades\r\n          },\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: `${seas}`\r\n          },\r\n          {\r\n            fieldName: 'site',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${wht[0].location}`\r\n          },\r\n          {\r\n            fieldName: 'status',\r\n            operator: 'ne',\r\n            value: 'Expired'\r\n          },\r\n          {\r\n            fieldName: 'marketType',\r\n            operator: 'eqCaseInsensitive',\r\n            value: 'Pool'\r\n          },\r\n          {\r\n            fieldName: 'startDateTime',\r\n            operator: 'lte',\r\n            value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n          },\r\n          {\r\n            fieldName: 'endDateTime',\r\n            operator: 'gte',\r\n            value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n          }\r\n        ]\r\n      }\r\n    };\r\n\r\n    const gpsCashData = getRequestBodyPost(\r\n      req.body.propertyList.eka_connect_host +\r\n        '/data/getDistinctValues/12325a98-a959-4939-9005-4158d136afcd/ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40',\r\n      cashObj\r\n    );\r\n\r\n    const allGpsCashData = getRequestBodyPost(\r\n      req.body.propertyList.eka_connect_host +\r\n        '/data/12325a98-a959-4939-9005-4158d136afcd/ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40',\r\n      allCashObj\r\n    );\r\n\r\n    const gpsPoolData = getRequestBodyPost(\r\n      req.body.propertyList.eka_connect_host +\r\n        '/data/getDistinctValues/12325a98-a959-4939-9005-4158d136afcd/ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40',\r\n      poolObj\r\n    );\r\n\r\n    const allGpsPoolData = getRequestBodyPost(\r\n      req.body.propertyList.eka_connect_host +\r\n        '/data/12325a98-a959-4939-9005-4158d136afcd/ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40',\r\n      allPoolObj\r\n    );\r\n\r\n    let pprObj = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: `${seas}`\r\n          },\r\n          {\r\n            fieldName: 'signed',\r\n            operator: 'eq',\r\n            value: 'Y'\r\n          },\r\n          {\r\n            fieldName: 'marketType',\r\n            operator: 'eqCaseInsensitive',\r\n            value: 'Contract'\r\n          },\r\n          {\r\n            fieldName: 'isActive',\r\n            operator: 'eq',\r\n            value: 'Y'\r\n          },\r\n          {\r\n            fieldName: 'isInternalBp',\r\n            operator: 'eq',\r\n            value: 'Y'\r\n          },\r\n          {\r\n            fieldName: 'bpName',\r\n            operator: 'eqCaseInsensitive',\r\n            value: 'AWB'\r\n          }\r\n        ]\r\n      }\r\n    };\r\n\r\n    let pprNonCargillObj = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: `${seas}`\r\n          },\r\n          {\r\n            fieldName: 'signed',\r\n            operator: 'eq',\r\n            value: 'Y'\r\n          },\r\n          {\r\n            fieldName: 'marketType',\r\n            operator: 'eqCaseInsensitive',\r\n            value: 'Contract'\r\n          },\r\n          {\r\n            fieldName: 'isActive',\r\n            operator: 'eq',\r\n            value: 'Y'\r\n          },\r\n          {\r\n            fieldName: 'isInternalBp',\r\n            operator: 'ne',\r\n            value: 'Y'\r\n          }\r\n        ]\r\n      },\r\n      distinctColumns: ['bpName']\r\n    };\r\n\r\n    const pprData = getRequestBodyPost(\r\n      req.body.propertyList.eka_connect_host +\r\n        '/data/12325a98-a959-4939-9005-4158d136afcd/6d10c2dd-c5c5-451e-88f5-3de80e151bc3',\r\n      pprObj\r\n    );\r\n\r\n    const pprNonCargillData = getRequestBodyPost(\r\n      req.body.propertyList.eka_connect_host +\r\n        '/data/getDistinctValues/12325a98-a959-4939-9005-4158d136afcd/6d10c2dd-c5c5-451e-88f5-3de80e151bc3',\r\n      pprNonCargillObj\r\n    );\r\n\r\n    let ctrmObj = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'gradeCombined',\r\n            operator: 'all',\r\n            value: grades\r\n          },\r\n          {\r\n            fieldName: 'cropYear',\r\n            operator: 'eq',\r\n            value: `${seas}`\r\n          },\r\n          {\r\n            fieldName: 'BPRefNo',\r\n            operator: 'eq',\r\n            value: `${wht[0].bpRefNo}`\r\n          },\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${pro}`\r\n          },\r\n          {\r\n            fieldName: 'userType',\r\n            operator: 'eq',\r\n            value: 'Grower'\r\n          },\r\n          {\r\n            fieldName: 'fulfillmentStatus',\r\n            operator: 'eq',\r\n            value: 'Not Fulfilled'\r\n          },\r\n          {\r\n            fieldName: 'itemOpenQuantityInBase',\r\n            operator: 'gte',\r\n            value: 0\r\n          },\r\n          {\r\n            fieldName: 'dischargeLocationCityCombined',\r\n            operator: 'allCaseInsensitive',\r\n            value: locations\r\n          },\r\n          {\r\n            fieldName: 'isRequestedByEkaCCSystem',\r\n            value: true,\r\n            operator: 'ne'\r\n          }\r\n        ]\r\n      },\r\n      distinctColumns: ['contractRefNo']\r\n    };\r\n\r\n    let allContractObj = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'gradeCombined',\r\n            operator: 'all',\r\n            value: grades\r\n          },\r\n          {\r\n            fieldName: 'cropYear',\r\n            operator: 'eq',\r\n            value: `${seas}`\r\n          },\r\n          {\r\n            fieldName: 'BPRefNo',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${wht[0].bpRefNo}`\r\n          },\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eqCaseInsensitive',\r\n            value: `${pro}`\r\n          },\r\n          {\r\n            fieldName: 'userType',\r\n            operator: 'eq',\r\n            value: 'Grower'\r\n          },\r\n          {\r\n            fieldName: 'fulfillmentStatus',\r\n            operator: 'eq',\r\n            value: 'Not Fulfilled'\r\n          },\r\n          {\r\n            fieldName: 'itemOpenQuantityInBase',\r\n            operator: 'gte',\r\n            value: 0\r\n          },\r\n          {\r\n            fieldName: 'dischargeLocationCityCombined',\r\n            operator: 'allCaseInsensitive',\r\n            value: locations\r\n          },\r\n          {\r\n            fieldName: 'isRequestedByEkaCCSystem',\r\n            value: true,\r\n            operator: 'ne'\r\n          }\r\n        ]\r\n      }\r\n    };\r\n\r\n    const ctrmData = getRequestBodyPost(\r\n      req.body.propertyList.eka_connect_host +\r\n        '/data/getDistinctValues/12325a98-a959-4939-9005-4158d136afcd/46e84f42-6288-4027-b6d0-fd1c11019259',\r\n      ctrmObj\r\n    );\r\n\r\n    const allContractData = getRequestBodyPost(\r\n      req.body.propertyList.eka_connect_host +\r\n        '/data/12325a98-a959-4939-9005-4158d136afcd/46e84f42-6288-4027-b6d0-fd1c11019259',\r\n      allContractObj\r\n    );\r\n\r\n    const pprCargill = new Promise((resolve, reject) => {\r\n      getData(pprData)\r\n        .then(data => {\r\n          resolve(data);\r\n        })\r\n        .catch(err => {\r\n          reject(\"Couldn't get price publish data for cargill\");\r\n        });\r\n    });\r\n\r\n    const pprNonCargill = new Promise((resolve, reject) => {\r\n      getData(pprNonCargillData)\r\n        .then(data => {\r\n          resolve(data);\r\n        })\r\n        .catch(err => {\r\n          reject(\"Couldn't get price publish data for non cargill\");\r\n        });\r\n    });\r\n\r\n    const fetchContracts = new Promise((resolve, reject) => {\r\n      getData(ctrmData)\r\n        .then(data => {\r\n          resolve(data);\r\n        })\r\n        .catch(err => {\r\n          reject(\"Couldn't fetch the contracts\");\r\n        });\r\n    });\r\n    const timeLable = 'Time taken by seller key';\r\n    const promise1 = new Promise((resolve, reject) => {\r\n      console.time(timeLable);\r\n      Promise.all([pprCargill, pprNonCargill, fetchContracts])\r\n        .then(res => {\r\n          console.timeEnd(timeLable);\r\n\r\n          let acquirers = [];\r\n\r\n          if (res[0].length > 0 && res[2].contractRefNo.length > 0) {\r\n            acquirers.push({ key: 'AWB # External', value: 'AWB' });\r\n          }\r\n\r\n          if (res[1].bpName.length > 0) {\r\n            let arr = res[1].bpName.map(item => ({ key: item, value: item }));\r\n            acquirers = [...acquirers, ...arr];\r\n          }\r\n\r\n          resolve(acquirers);\r\n        })\r\n        .catch(err => {\r\n          reject(err);\r\n        });\r\n    });\r\n    const timeLableCash = 'Time taken by cash key';\r\n    const promise2 = new Promise((resolve, reject) => {\r\n      console.time(timeLableCash);\r\n      getData(gpsCashData)\r\n        .then(data => {\r\n          console.timeEnd(timeLableCash);\r\n\r\n          let gps = data.bpName.map(item => ({\r\n            key: item + ' # Cash',\r\n            value: item\r\n          }));\r\n          resolve(gps);\r\n        })\r\n        .catch(err => {\r\n          reject(\"Couldn't fetch cash prices\");\r\n        });\r\n    });\r\n\r\n    const timeLablePool = 'Time taken by pool key';\r\n    const promise3 = new Promise((resolve, reject) => {\r\n      console.time(timeLablePool);\r\n\r\n      getData(gpsPoolData)\r\n        .then(data => {\r\n          console.timeEnd(timeLablePool);\r\n\r\n          let gps = data.bpName.map(item => ({\r\n            key: item + ' # Pool',\r\n            value: item\r\n          }));\r\n\r\n          resolve(gps);\r\n        })\r\n        .catch(err => {\r\n          reject(\"Couldn't fetch pool prices\");\r\n        });\r\n    });\r\n\r\n    if (serviceKey == 'sellerKey') {\r\n      const timeLable = 'Time taken by all three';\r\n      console.time(timeLable);\r\n      Promise.all([promise1, promise2, promise3])\r\n        .then(arr => {\r\n          console.log('Seller key is resolved', JSON.stringify(arr[2]));\r\n          console.timeEnd(timeLable);\r\n          res.status(200).send({\r\n            sellerKey: [\r\n              {\r\n                key: 'Contract',\r\n                value: 'Contract',\r\n                class: 'radio-card',\r\n                class: arr[0].length == 0 ? 'radio-card-disable' : 'radio-card',\r\n                description: 'Allocate to a Cargill or third-party contract'\r\n              },\r\n              {\r\n                key: 'Cash',\r\n                value: 'Cash',\r\n                class: arr[1].length == 0 ? 'radio-card-disable' : 'radio-card',\r\n                description: 'Allocate to a cash bid'\r\n              },\r\n              {\r\n                key: 'Pool',\r\n                value: 'Pool',\r\n                class: arr[2].length == 0 ? 'radio-card-disable' : 'radio-card',\r\n                description: 'Allocate to a pool'\r\n              }\r\n            ]\r\n          });\r\n        })\r\n        .catch(err => {\r\n          res.status(500).send(err);\r\n        });\r\n    }\r\n\r\n    if (serviceKey == 'acquirerKey') {\r\n      let dependsOn = req.body.mdmProcessorServiceKey[0].dependsOn[0];\r\n\r\n      if (dependsOn == '') {\r\n        res.status(200).send({\r\n          acquirerKey: []\r\n        });\r\n      } else if (dependsOn == 'Contract') {\r\n        Promise.all([promise1]).then(arr => {\r\n          res.status(200).send({\r\n            acquirerKey: arr[0]\r\n              .map(i => i.key)\r\n              .sort(function(a, b) {\r\n                return a.toLowerCase().localeCompare(b.toLowerCase());\r\n              })\r\n              .map(i => ({ key: i, value: i.split('#')[0] }))\r\n          });\r\n        });\r\n      } else if (dependsOn == 'Cash') {\r\n        Promise.all([promise2]).then(arr => {\r\n          res.status(200).send({\r\n            acquirerKey: arr[0],\r\n            sustainableKey: ['Yes', 'No'].map(item => ({\r\n              key: item,\r\n              value: item\r\n            }))\r\n          });\r\n        });\r\n      } else {\r\n        Promise.all([promise3]).then(arr => {\r\n          res.status(200).send({\r\n            acquirerKey: arr[0]\r\n              .map(i => i.key)\r\n              .sort(function(a, b) {\r\n                return a.toLowerCase().localeCompare(b.toLowerCase());\r\n              })\r\n              .map(i => ({ key: i, value: i.split('#')[0] }))\r\n          });\r\n        });\r\n      }\r\n    }\r\n\r\n    if (serviceKey == 'cashacquirerKey') {\r\n      let dependsOn = req.body.mdmProcessorServiceKey[0].dependsOn[0];\r\n      getData(allGpsCashData).then(data => {\r\n        if (dependsOn == 'Yes') {\r\n          let arr = data.filter(item => item.sustainable);\r\n          if (arr.length == 0) {\r\n            res.status(500).send('No acquirers present for this combination');\r\n            return;\r\n          }\r\n          res.status(200).send({\r\n            cashacquirerKey: arr\r\n              .map(i => i.bpName)\r\n              .sort(function(a, b) {\r\n                return a.toLowerCase().localeCompare(b.toLowerCase());\r\n              })\r\n              .map(i => ({ key: i + ' # Cash_SY', value: i }))\r\n          });\r\n        } else {\r\n          let arr = data.filter(item => !item.sustainable);\r\n          if (arr.length == 0) {\r\n            res.status(500).send('No acquirers present for this combination');\r\n            return;\r\n          }\r\n          res.status(200).send({\r\n            cashacquirerKey: arr\r\n              .map(i => i.bpName)\r\n              .sort(function(a, b) {\r\n                return a.toLowerCase().localeCompare(b.toLowerCase());\r\n              })\r\n              .map(i => ({ key: i + ' # Cash_SN', value: i }))\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    if (serviceKey == 'contractKey') {\r\n      let dependson = req.body.mdmProcessorServiceKey[0].dependsOn[0].split('#')[0].trim();\r\n      let isExternal = req.body.mdmProcessorServiceKey[0].dependsOn[0].split('#')[1] == undefined;\r\n      let so = req.body.selectedData.allocateticketscomposite.entersellingoptions.sellingOption;\r\n\r\n      if (dependson == '' || isExternal) {\r\n        const clientCode = bpName =>\r\n          getRequestBody(\r\n            req.body.propertyList.eka_connect_host +\r\n              '/data/12325a98-a959-4939-9005-4158d136afcd/6d10c2dd-c5c5-451e-88f5-3de80e151bc3?bpName=' +\r\n              bpName\r\n          );\r\n\r\n        const promise = new Promise((resolve, reject) => {\r\n          getData(clientCode(dependson))\r\n            .then(pprData => {\r\n              if (pprData.length == 0) {\r\n                res.status(500).send('No record found in Price Publish Rights');\r\n              }\r\n\r\n              let pprObj = {\r\n                filterData: {\r\n                  filter: [\r\n                    {\r\n                      fieldName: 'cropYear',\r\n                      operator: 'eq',\r\n                      value: `${seas}`\r\n                    },\r\n                    {\r\n                      fieldName: 'ticketHandlerCode',\r\n                      operator: 'eqCaseInsensitive',\r\n                      value: pprData[0].bpExternalCode\r\n                    }\r\n                  ]\r\n                },\r\n                distinctColumns: ['contractId']\r\n              };\r\n\r\n              const ticketData = getRequestBodyPost(\r\n                req.body.propertyList.eka_connect_host +\r\n                  '/data/getDistinctValues/12325a98-a959-4939-9005-4158d136afcd/a26737b3-a5a9-4fe9-b6f7-29218a3bc45a',\r\n                pprObj\r\n              );\r\n\r\n              getData(ticketData)\r\n                .then(data => {\r\n                  resolve(data.contractId);\r\n                })\r\n                .catch(err => {\r\n                  reject(\"Couldn't fetch contract Id's\");\r\n                });\r\n            })\r\n            .catch(err => {\r\n              reject(\"Couldn't fetch price publish data for non cargill acquirers\");\r\n            });\r\n        });\r\n\r\n        promise\r\n          .then(data => {\r\n            res.status(200).send({\r\n              externalContractKey: data\r\n                .filter(n => n)\r\n                .map(item => ({\r\n                  key: item,\r\n                  value: item\r\n                }))\r\n            });\r\n          })\r\n          .catch(err => {\r\n            res.status(500).send(err);\r\n          });\r\n      } else {\r\n        if (so == 'Contract') {\r\n          const promise = new Promise((resolve, reject) => {\r\n            getData(ctrmData)\r\n              .then(data => {\r\n                if (dependson === 'AWB') {\r\n                  resolve(data);\r\n                }\r\n              })\r\n              .catch(err => {\r\n                reject(\"Didn't get any Contract Numbers\");\r\n              });\r\n          });\r\n\r\n          promise.then(data => {\r\n            res.status(200).send({\r\n              contractKey: data.contractRefNo.map(item => ({\r\n                key: item,\r\n                value: item\r\n              }))\r\n            });\r\n          });\r\n        } else if (so == 'Pool') {\r\n          let allGpsObj = {\r\n            filterData: {\r\n              filter: [\r\n                {\r\n                  fieldName: 'product',\r\n                  operator: 'eqCaseInsensitive',\r\n                  value: `${pro}`\r\n                },\r\n                {\r\n                  fieldName: 'quality',\r\n                  operator: 'in',\r\n                  value: cashPoolGrades\r\n                },\r\n                {\r\n                  fieldName: 'season',\r\n                  operator: 'eq',\r\n                  value: `${seas}`\r\n                },\r\n                {\r\n                  fieldName: 'site',\r\n                  operator: 'eqCaseInsensitive',\r\n                  value: `${wht[0].location}`\r\n                },\r\n                {\r\n                  fieldName: 'status',\r\n                  operator: 'ne',\r\n                  value: 'Expired'\r\n                },\r\n                {\r\n                  fieldName: 'marketType',\r\n                  operator: 'eqCaseInsensitive',\r\n                  value: 'Pool'\r\n                },\r\n                {\r\n                  fieldName: 'startDateTime',\r\n                  operator: 'lte',\r\n                  value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n                },\r\n                {\r\n                  fieldName: 'endDateTime',\r\n                  operator: 'gte',\r\n                  value: moment.utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\r\n                },\r\n                {\r\n                  fieldName: 'bpName',\r\n                  operator: 'eqCaseInsensitive',\r\n                  value: dependson\r\n                }\r\n              ]\r\n            },\r\n            distinctColumns: ['pricingOption']\r\n          };\r\n\r\n          const allGpsPool = getRequestBodyPost(\r\n            req.body.propertyList.eka_connect_host +\r\n              '/data/getDistinctValues/12325a98-a959-4939-9005-4158d136afcd/ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40',\r\n            allGpsObj\r\n          );\r\n\r\n          getData(allGpsPool).then(data => {\r\n            res.status(200).send({\r\n              pricingOptionkey: data.pricingOption.map(item => ({\r\n                key: item,\r\n                value: item\r\n              }))\r\n            });\r\n          });\r\n        } else {\r\n          res.status(200).send({\r\n            pricingOptionkey: [],\r\n            externalContractKey: [],\r\n            contractKey: []\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    if (serviceKey === 'externalPriceKey') {\r\n      res.status(200).send({\r\n        externalPriceKey: null,\r\n        externalQuantityKey: null\r\n      });\r\n    }\r\n\r\n    if (serviceKey === 'priceKey') {\r\n      let dependsOn = req.body.mdmProcessorServiceKey[0].dependsOn[0].split('#')[0].trim();\r\n      let so = req.body.selectedData.allocateticketscomposite.entersellingoptions.sellingOption;\r\n\r\n      if (dependsOn == '') {\r\n        res.status(200).send({\r\n          priceKey: []\r\n        });\r\n      } else {\r\n        if (so == 'Contract') {\r\n          getData(pprData)\r\n            .then(pricePublishData => {\r\n              getData(allContractData)\r\n                .then(cargillData => {\r\n                  if (pricePublishData.length > 0 && cargillData.length > 0) {\r\n                    let mdmCollection = prepareMdmCollection(cargillData);\r\n                    res.status(200).send({\r\n                      priceKey: Object.keys(mdmCollection['priceKey'][dependsOn])[0],\r\n                      quantityKey: Object.keys(mdmCollection['quantityKey'][dependsOn])[0],\r\n                      shipmentStartKey: Object.keys(mdmCollection['shipmentStartKey'][dependsOn])[0],\r\n                      shipmentEndKey: Object.keys(mdmCollection['shipmentEndKey'][dependsOn])[0],\r\n                      multigradeKey: Object.keys(mdmCollection['multigradeKey'][dependsOn])[0],\r\n                      priceTypeKey: Object.keys(mdmCollection['priceTypeKey'][dependsOn])[0],\r\n                      spreadKey: Object.keys(mdmCollection['spreadKey'][dependsOn])[0],\r\n                      approvalKey: Object.keys(mdmCollection['approvalKey'][dependsOn])[0]\r\n                    });\r\n                  }\r\n                })\r\n                .catch(err => {\r\n                  res.status(500).send(err);\r\n                });\r\n            })\r\n            .catch(err => {\r\n              res.status(500).send(err);\r\n            });\r\n        }\r\n      }\r\n    }\r\n\r\n    if (serviceKey == 'cashPriceKey') {\r\n      let dependson = req.body.mdmProcessorServiceKey[0].dependsOn[0].split('#')[0].trim();\r\n      let isSustainable = req.body.mdmProcessorServiceKey[0].dependsOn[0].split('#')[1].trim();\r\n\r\n      if (isSustainable === 'Cash_SY') {\r\n        allCashObj.filterData.filter.push({ fieldName: 'sustainable', operator: 'eq', value: true });\r\n      } else {\r\n        allCashObj.filterData.filter.push({ fieldName: 'sustainable', operator: 'eq', value: false });\r\n      }\r\n\r\n      getData(allGpsCashData).then(data => {\r\n        let mdmCollection = prepareMdmCollection(data);\r\n        res.status(200).send({\r\n          cashPriceKey: Object.keys(mdmCollection['cashPriceKey'][dependson])[0],\r\n          cashClientCodeKey: Object.keys(mdmCollection['cashClientCodeKey'][dependson])[0],\r\n          cashBpRefNumberKey: Object.keys(mdmCollection['cashBpRefNumberKey'][dependson])[0],\r\n          isInternalBpCashKey: Object.keys(mdmCollection['isInternalBpCashKey'][dependson])[0]\r\n        });\r\n      });\r\n    }\r\n\r\n    if (serviceKey == 'poolPriceKey') {\r\n      let dependsOn = req.body.mdmProcessorServiceKey[0].dependsOn[0].split('#')[0].trim();\r\n\r\n      if (dependsOn === '') {\r\n        res.status(200).send({\r\n          poolPriceKey: []\r\n        });\r\n      } else {\r\n        getData(allGpsPoolData).then(data => {\r\n          let mdmCollection = prepareMdmCollection(data);\r\n          res.status(200).send({\r\n            poolPriceKey: Object.keys(mdmCollection['poolpricekey'][dependsOn])[0],\r\n            poolClientCodeKey: Object.keys(mdmCollection['poolClientCodeKey'][dependsOn])[0],\r\n            poolBpRefNumberKey: Object.keys(mdmCollection['poolBpRefNumberKey'][dependsOn])[0],\r\n            isInternalBpPoolKey: Object.keys(mdmCollection['isInternalBpPoolKey'][dependsOn])[0]\r\n          });\r\n        });\r\n      }\r\n    }",
  "sys__UUID": "7ebfbc54-f2e0-4d09-9eb3-37066d01e721"
}

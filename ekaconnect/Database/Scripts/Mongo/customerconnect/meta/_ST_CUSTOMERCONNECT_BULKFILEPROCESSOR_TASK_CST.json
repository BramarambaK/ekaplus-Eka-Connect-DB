{
  "_id": "_ST_CUSTOMERCONNECT_BULKFILEPROCESSOR_TASK_CST",
  "name": "_ST_CUSTOMERCONNECT_BULKFILEPROCESSOR_TASK_CST",
  "type": "processor",
  "refType": "app",
  "isNode": true,
  "refTypeId": "12325a98-a959-4939-9005-4158d136afcd",
  "snippet": " var moment = require('moment');\r\n    const appId = '12325a98-a959-4939-9005-4158d136afcd';\r\n    const filesObjId = '900fcf0a-cbc5-4de1-ad8c-c2987f196cd5';\r\n    const tonnageObjId = 'c98119db-1f7c-4802-b72a-6678f1ecc0f3';\r\n    const minMaxObjId = '8f13785a-0475-47c5-ab59-f42c132d6a33';\r\n    const masterData = '6d10c2dd-c5c5-451e-88f5-3de80e151bc3';\r\n    const commoditiesObjId = 'ae5f314e-c377-419e-9dfa-1f296f6fccfa';\r\n    const regionsObjId = 'ac4bf583-a9a4-446d-b6f9-3c083c3e1030';\r\n    const tenant = req.headers['x-tenantid'];\r\n    const serverTimezoneOffset = new Date().getTimezoneOffset();\r\n    const send = (status, message) => {\r\n      return res.status(status).send(message);\r\n    };\r\n    const getObjectUri = id => `${req.body.propertyList.eka_connect_host}/data/${appId}/${id}`;\r\n\r\n    const getData = (url, body) =>\r\n      new Promise(function(resolve, reject) {\r\n        request(\r\n          {\r\n            method: 'GET',\r\n            url,\r\n            headers: {\r\n              Authorization: req.headers.authorization,\r\n              'X-TenantID': tenant\r\n            },\r\n            json: true,\r\n            body\r\n          },\r\n          function(err, response, body) {\r\n            if (response && response.statusCode >= 200 && response.statusCode <= 299) {\r\n              resolve(body);\r\n            } else {\r\n              reject(body);\r\n            }\r\n          }\r\n        );\r\n      });\r\n\r\n    const requiredFields = ['Grade', 'Site', 'End date', 'End time', 'Pricing Option', 'Sustainable'];\r\n\r\n    const timeFormatRegex = new RegExp(/^([0-1]?[0-9]|2[0-3])(:[0-5][0-9]){1,2}$/);\r\n\r\n    const fileId = req.body.id;\r\n    const getCommodities = new Promise((resolve, reject) =>\r\n      getData(getObjectUri(commoditiesObjId))\r\n        .then(result => resolve(result))\r\n        .catch(err => {\r\n          reject(err);\r\n        })\r\n    );\r\n    const getRegions = new Promise((resolve, reject) =>\r\n      getData(getObjectUri(regionsObjId))\r\n        .then(result => resolve(result))\r\n        .catch(err => {\r\n          reject(err);\r\n        })\r\n    );\r\n    const fileDetails = new Promise((resolve, reject) =>\r\n      getData(`${getObjectUri(filesObjId)}?documentId=${fileId}`)\r\n        .then(result => resolve(result.map(i => i.fileContent)))\r\n        .catch(err => {\r\n          reject(err);\r\n        })\r\n    );\r\n\r\n    const equal = (i, j) =>\r\n      i.quality == j.quality &&\r\n      i.site == j.site &&\r\n      i.pricingOption == j.pricingOption &&\r\n      i.season == j.season &&\r\n      i.sustainable == j.sustainable &&\r\n      ((i.startDate == j.startDate && i.startTime == j.startTime && i.endDate == j.endDate && i.endTime == j.endTime) ||\r\n        (moment(j.startDate + ' ' + j.startTime, 'DD/MM/YYYY HH:mm').isBetween(\r\n          moment(i.startDate + ' ' + i.startTime, 'DD/MM/YYYY HH:mm'),\r\n          moment(i.endDate + ' ' + i.endTime, 'DD/MM/YYYY HH:mm'),\r\n          undefined,\r\n          '[)'\r\n        ) ||\r\n          moment(j.endDate + ' ' + j.endTime, 'DD/MM/YYYY HH:mm').isBetween(\r\n            moment(i.startDate + ' ' + i.startTime, 'DD/MM/YYYY HH:mm'),\r\n            moment(i.endDate + ' ' + i.endTime, 'DD/MM/YYYY HH:mm'),\r\n            undefined,\r\n            '[)'\r\n          ) ||\r\n          moment(i.startDate + ' ' + i.startTime, 'DD/MM/YYYY HH:mm').isBetween(\r\n            moment(j.startDate + ' ' + j.startTime, 'DD/MM/YYYY HH:mm'),\r\n            moment(j.endDate + ' ' + j.endTime, 'DD/MM/YYYY HH:mm'),\r\n            undefined,\r\n            '[)'\r\n          ) ||\r\n          moment(i.endDate + ' ' + i.endTime, 'DD/MM/YYYY HH:mm').isBetween(\r\n            moment(j.startDate + ' ' + j.startTime, 'DD/MM/YYYY HH:mm'),\r\n            moment(j.endDate + ' ' + j.endTime, 'DD/MM/YYYY HH:mm'),\r\n            undefined,\r\n            '[)'\r\n          )));\r\n\r\n    const getTonnage = (bpRefNo, bpExternalCode, season) =>\r\n      new Promise((resolve, reject) => {\r\n        getData(\r\n          getObjectUri(tonnageObjId) +\r\n            `?bpRefNo=${bpRefNo}&season=${season}${bpExternalCode ? '&bpExternalCode=' + bpExternalCode : ''}`,\r\n          {}\r\n        ).then(tonnage => {\r\n          resolve(tonnage);\r\n        });\r\n      });\r\n\r\n    const getPricingOptions = (bpRefNo, bpExternalCode, season) =>\r\n      new Promise((resolve, reject) => {\r\n        getData(getObjectUri(masterData), {\r\n          includeFields: ['pricingOption', 'marketType'],\r\n          excludeFields: ['_id'],\r\n          filterData: {\r\n            filter: [\r\n              {\r\n                fieldName: 'bpRefNo',\r\n                value: bpRefNo,\r\n                operator: 'eq'\r\n              },\r\n              {\r\n                fieldName: 'bpExternalCode',\r\n                value: bpExternalCode,\r\n                operator: 'eq'\r\n              },\r\n              {\r\n                fieldName: 'season',\r\n                value: season,\r\n                operator: 'eq'\r\n              },\r\n              {\r\n                fieldName: 'signed',\r\n                value: 'Y',\r\n                operator: 'eq'\r\n              },\r\n              {\r\n                fieldName: 'isActive',\r\n                value: 'Y',\r\n                operator: 'eq'\r\n              },\r\n              {\r\n                fieldName: 'marketType',\r\n                value: 'Contract',\r\n                operator: 'ne'\r\n              }\r\n            ]\r\n          }\r\n        }).then(pricingOptions => resolve(pricingOptions));\r\n      });\r\n\r\n    const getMinMaxPrice = getData(getObjectUri(minMaxObjId));\r\n\r\n    const bpDetails = req.body.account.split(' @#@ ');\r\n    const season = req.body.harvestseason;\r\n    const clientTimezoneOffset = req.body.ClientTimezone;\r\n    const today = moment(moment().format('YYYY-MM-DD HH:mm'), 'YYYY-MM-DD HH:mm').add(\r\n      clientTimezoneOffset ? serverTimezoneOffset - clientTimezoneOffset : 0,\r\n      'minutes'\r\n    );\r\n    let success = true;\r\n    Promise.all([\r\n      fileDetails,\r\n      getTonnage(bpDetails[0], bpDetails[3], season),\r\n      getPricingOptions(bpDetails[0], bpDetails[3], season),\r\n      getMinMaxPrice,\r\n      getCommodities,\r\n      getRegions\r\n    ]).then(arr => {\r\n      try {\r\n        const content = arr[0];\r\n        const tonnages = arr[1];\r\n        const pricingOptions = arr[2];\r\n        const minMaxPrices = arr[3];\r\n        const commoditesMaster = arr[4];\r\n        const regionMaster = arr[5];\r\n\r\n        const contentToModify = [];\r\n        content.forEach((item, index) => {\r\n          if (\r\n            item['Grade'] == '' &&\r\n            item['Site'] == '' &&\r\n            item['Price'] == '' &&\r\n            item['Start date'] == '' &&\r\n            item['Start time'] == '' &&\r\n            item['End time'] == '' &&\r\n            item['End date'] == '' &&\r\n            item['Pricing Option'] == '' &&\r\n            item['Sustainable'] == ''\r\n          )\r\n            contentToModify.push(index);\r\n        });\r\n        contentToModify.reverse().forEach(i => {\r\n          content.splice(i, 1);\r\n        });\r\n        const data = content.reduce(\r\n          (acc, curr, index, arr) => {\r\n            const commodityGrade = commoditesMaster.find(i => i.quality == curr['Grade']);\r\n            const regionSite = regionMaster.find(i => i.site == curr['Site']);\r\n            const validSite = !!regionSite;\r\n            const validGrade = !!commodityGrade;\r\n            const allGrades = tonnages.find(\r\n              i =>\r\n                validGrade &&\r\n                validSite &&\r\n                i.region == regionSite.region &&\r\n                i.product == commodityGrade.product &&\r\n                i.quality.toLowerCase() == 'all' &&\r\n                i.site == curr['Site'] &&\r\n                i.limitBreachStatus == 'Y'\r\n            );\r\n            const allSites = tonnages.find(\r\n              i =>\r\n                validGrade &&\r\n                validSite &&\r\n                i.region == regionSite.region &&\r\n                i.product == commodityGrade.product &&\r\n                i.site.toLowerCase() == 'all' &&\r\n                i.quality == curr['Grade'] &&\r\n                i.limitBreachStatus == 'Y'\r\n            );\r\n            const allGradesSites = tonnages.find(\r\n              i =>\r\n                validGrade &&\r\n                validSite &&\r\n                i.product == commodityGrade.product &&\r\n                i.region == regionSite.region &&\r\n                i.site.toLowerCase() == 'all' &&\r\n                i.quality.toLowerCase() == 'all'\r\n            );\r\n            const remarks = [];\r\n            const emptyField = requiredFields.filter(i => curr[i] == '' || curr[i] == null);\r\n\r\n            curr['Start date'] =\r\n              curr['Start date'] == ''\r\n                ? moment()\r\n                    .add(clientTimezoneOffset ? serverTimezoneOffset - clientTimezoneOffset : 0, 'minutes')\r\n                    .format('DD/MM/YYYY')\r\n                : curr['Start date'];\r\n            curr['Start time'] =\r\n              curr['Start time'] == ''\r\n                ? moment(curr['Start date'], 'DD/MM/YYYY').isAfter(today)\r\n                  ? '00:00'\r\n                  : moment()\r\n                      .add(clientTimezoneOffset ? serverTimezoneOffset - clientTimezoneOffset : 0, 'minutes')\r\n                      .format('HH:mm')\r\n                : moment(curr['Start date'] + ' ' + curr['Start time'], 'DD/MM/YYYY HH:mm').isSameOrBefore(today)\r\n                ? moment()\r\n                    .add(clientTimezoneOffset ? serverTimezoneOffset - clientTimezoneOffset : 0, 'minutes')\r\n                    .format('HH:mm')\r\n                : curr['Start time'];\r\n            const publishImmediately = moment(\r\n              curr['Start date'] + ' ' + curr['Start time'],\r\n              'DD/MM/YYYY HH:mm'\r\n            ).isAfter(today)\r\n              ? false\r\n              : true;\r\n            const startDate = moment(curr['Start date'], 'DD/MM/YYYY');\r\n            const endDate = moment(curr['End date'], 'DD/MM/YYYY');\r\n            const startDateTime = moment(\r\n              startDate.format('YYYY-MM-DD') + ' ' + curr['Start time'],\r\n              'YYYY-MM-DD HH:mm'\r\n            ).utc();\r\n            const endDateTime = moment(endDate.format('YYYY-MM-DD') + ' ' + curr['End time'], 'YYYY-MM-DD HH:mm').utc();\r\n\r\n            if (\r\n              startDateTime.isValid() &&\r\n              endDateTime.isValid() &&\r\n              (startDateTime.isSameOrAfter(endDateTime) || endDateTime.isSameOrBefore(today))\r\n            ) {\r\n              remarks.push('End date & time cannot be before both now and start date & time');\r\n            }\r\n\r\n            if (!startDate.isValid() || !timeFormatRegex.test(curr['Start time'])) {\r\n              remarks.push('Invalid start date/time. Format is DD/MM/YYYY HH:MM');\r\n            } else {\r\n              curr['Start time'] = moment(curr['Start time'], 'HH:mm').format('HH:mm');\r\n            }\r\n\r\n            if (!endDate.isValid() || !timeFormatRegex.test(curr['End time'])) {\r\n              remarks.push('Invalid end date/time. Format is DD/MM/YYYY HH:MM');\r\n            } else {\r\n              curr['End time'] = moment(curr['End time'], 'HH:mm').format('HH:mm');\r\n            }\r\n\r\n            const duplicate = arr.find(\r\n              (i, ind) =>\r\n                equal(\r\n                  {\r\n                    quality: curr.Grade,\r\n                    site: curr.Site,\r\n                    pricingOption: curr['Pricing Option'],\r\n                    season: season,\r\n                    startDate: curr['Start date'],\r\n                    startTime: curr['Start time'],\r\n                    endDate: curr['End date'],\r\n                    endTime: curr['End time'],\r\n                    sustainable: curr['Sustainable']\r\n                  },\r\n                  {\r\n                    quality: i.Grade,\r\n                    site: i.Site,\r\n                    pricingOption: i['Pricing Option'],\r\n                    season: season,\r\n                    startDate: i['Start date'],\r\n                    startTime: i['Start time'],\r\n                    endDate: i['End date'],\r\n                    endTime: i['End time'],\r\n                    sustainable: i['Sustainable']\r\n                  }\r\n                ) && ind != index\r\n            );\r\n\r\n            let tonnage;\r\n            if (validSite && validGrade) {\r\n              // if (!(allGrades || allSites)) {\r\n              //   tonnage = tonnages.find(\r\n              //     i =>\r\n              //       i.product == commodityGrade.product &&\r\n              //       i.region == regionSite.region &&\r\n              //       i.quality == curr['Grade'] &&\r\n              //       i.site == curr['Site']\r\n              //   );\r\n              // } else\r\n              // {\r\n              if (allGrades) {\r\n                tonnage = tonnages.find(\r\n                  i =>\r\n                    i.product == commodityGrade.product &&\r\n                    i.region == regionSite.region &&\r\n                    i.quality.toLowerCase() == 'all' &&\r\n                    i.site == curr['Site']\r\n                );\r\n                if (tonnage && commodityGrade) {\r\n                  tonnage = {\r\n                    ...tonnage,\r\n                    ...commodityGrade\r\n                  };\r\n                }\r\n              } else if (allSites) {\r\n                tonnage = tonnages.find(\r\n                  i =>\r\n                    i.product == commodityGrade.product &&\r\n                    i.region == regionSite.region &&\r\n                    i.quality == curr['Grade'] &&\r\n                    i.site.toLowerCase() == 'all'\r\n                );\r\n                if (tonnage && regionSite) {\r\n                  tonnage = {\r\n                    ...tonnage,\r\n                    ...regionSite\r\n                  };\r\n                }\r\n              } else if (allGradesSites) {\r\n                if (commodityGrade && regionSite) {\r\n                  tonnage = tonnages.find(\r\n                    i => i.quality == curr['Grade'] && i.site == curr['Site'] && i.limitBreachStatus == 'Y'\r\n                  );\r\n                  if (!tonnage) {\r\n                    tonnage = {\r\n                      ...allGradesSites,\r\n                      ...commodityGrade,\r\n                      ...regionSite\r\n                    };\r\n                  }\r\n                }\r\n              } else {\r\n                const allGrades1 = tonnages.find(\r\n                  i =>\r\n                    validGrade &&\r\n                    validSite &&\r\n                    i.region == regionSite.region &&\r\n                    i.product == commodityGrade.product &&\r\n                    i.quality.toLowerCase() == 'all' &&\r\n                    i.site == curr['Site']\r\n                );\r\n                const allSites1 = tonnages.find(\r\n                  i =>\r\n                    validGrade &&\r\n                    validSite &&\r\n                    i.region == regionSite.region &&\r\n                    i.product == commodityGrade.product &&\r\n                    i.site.toLowerCase() == 'all' &&\r\n                    i.quality == curr['Grade']\r\n                );\r\n                if (allGrades1) {\r\n                  tonnage = tonnages.find(\r\n                    i =>\r\n                      i.product == commodityGrade.product &&\r\n                      i.region == regionSite.region &&\r\n                      i.quality.toLowerCase() == 'all' &&\r\n                      i.site == curr['Site']\r\n                    );\r\n                    tonnage = tonnages.find(\r\n                      (i) =>\r\n                        i.quality == curr['Grade'] &&\r\n                        i.site == curr['Site'] &&\r\n                        i.limitBreachStatus == 'Y'\r\n                    );\r\n                  if (!tonnage && commodityGrade) {\r\n                    tonnage = {\r\n                      ...tonnage,\r\n                      ...commodityGrade\r\n                    };\r\n                  }\r\n                } else if (allSites1) {\r\n                  tonnage = tonnages.find(\r\n                    i =>\r\n                      i.product == commodityGrade.product &&\r\n                      i.region == regionSite.region &&\r\n                      i.quality == curr['Grade'] &&\r\n                      i.site.toLowerCase() == 'all'\r\n                    );\r\n                    tonnage = tonnages.find(\r\n                      (i) =>\r\n                        i.quality == curr['Grade'] &&\r\n                        i.site == curr['Site'] &&\r\n                        i.limitBreachStatus == 'Y'\r\n                    );\r\n                  if (!tonnage && regionSite) {\r\n                    tonnage = {\r\n                      ...tonnage,\r\n                      ...regionSite\r\n                    };\r\n                  }\r\n                } else {\r\n                  tonnage = tonnages.find(\r\n                    i =>\r\n                      i.product == commodityGrade.product &&\r\n                      i.region == regionSite.region &&\r\n                      i.quality == curr['Grade'] &&\r\n                      i.site == curr['Site']\r\n                  );\r\n                }\r\n              }\r\n              // }\r\n            }\r\n\r\n            const pricingOption = pricingOptions.find(i => i.pricingOption == curr['Pricing Option']);\r\n\r\n            const minMaxPrice = minMaxPrices.find(i => !!tonnage && i.product == tonnage.product);\r\n\r\n            if (emptyField && emptyField.length > 0) {\r\n              remarks.push(\r\n                emptyField.join(',') + (emptyField.length == 1 ? ' is a mandatory field' : ' are mandatory fields')\r\n              );\r\n            }\r\n\r\n            if (isNaN(curr['Price'])) {\r\n              remarks.push('Invalid price');\r\n            }\r\n\r\n            if (duplicate) {\r\n              remarks.push('Duplicate price identified');\r\n            }\r\n            if (tonnage) {\r\n              if (!minMaxPrice) {\r\n                remarks.push(`Price not seeded for ${tonnage.product}`);\r\n              } else {\r\n                if (+curr['Price'] < +minMaxPrice.minimumValue) {\r\n                  remarks.push('Price appears low');\r\n                } else if (+curr['Price'] > +minMaxPrice.maximumValue) {\r\n                  remarks.push('The price appears high. Please review');\r\n                }\r\n              }\r\n              if (tonnage.limitBreachStatus && tonnage.limitBreachStatus == 'Y') {\r\n                remarks.push(`Daily limit for the ${curr['Site']} and ${curr['Grade']} has been breached`);\r\n              }\r\n            } else if (!validSite || !validGrade) {\r\n              if (!validSite && !emptyField.includes('Site')) {\r\n                remarks.push(`Invalid site`);\r\n              }\r\n              if (!validGrade && !emptyField.includes('Grade')) {\r\n                remarks.push(`Invalid grade`);\r\n              }\r\n            } else {\r\n              remarks.push(`No tonnage limit set for ${curr['Grade']}/${curr['Site']}`);\r\n            }\r\n\r\n            if (!pricingOption) {\r\n              remarks.push('Pricing option not present');\r\n            }\r\n\r\n            if (curr['Pricing Option'] !== 'Cash' && curr['Sustainable'] === 'Yes') {\r\n              remarks.push('Pool prices cannot be sustainable');\r\n            }\r\n            if (remarks && remarks.length > 0) {\r\n              success = false;\r\n              acc.error.push({\r\n                ...curr,\r\n                Remarks: '\"' + remarks.join(', ') + '\"'\r\n              });\r\n            } else {\r\n              acc.error.push({\r\n                ...curr,\r\n                Remarks: ''\r\n              });\r\n              acc.success.push({\r\n                ...curr,\r\n                Quality: curr['Grade'],\r\n                Product: tonnage.product,\r\n                Region: tonnage.region,\r\n                'Market type': pricingOption.marketType,\r\n                'Start date': startDate.format('YYYY-MM-DD'),\r\n                'End date': endDate.format('YYYY-MM-DD'),\r\n                Sustainable: curr.Sustainable && curr.Sustainable.toLowerCase() === 'yes',\r\n                bpRefNo: bpDetails[0],\r\n                bpName: bpDetails[1],\r\n                bpExternalName: bpDetails[2],\r\n                bpExternalCode: bpDetails[3],\r\n                season: season,\r\n                publishImmediately: publishImmediately,\r\n                startDateTime:\r\n                  moment(startDate.format('YYYY-MM-DD') + 'T' + curr['Start time'] + ':00')\r\n                    .utc()\r\n                    .format()\r\n                    .substring(0, 19) + 'Z',\r\n                endDateTime:\r\n                  moment(endDate.format('YYYY-MM-DD') + 'T' + curr['End time'] + ':00')\r\n                    .utc()\r\n                    .format()\r\n                    .substring(0, 19) + 'Z'\r\n              });\r\n            }\r\n            return acc;\r\n          },\r\n          { success: [], error: [] }\r\n        );\r\n\r\n        send(200, {\r\n          id: fileId,\r\n          data: JSON.stringify(success ? data.success : data.error),\r\n          condition: success\r\n        });\r\n      } catch (e) {\r\n        send(400, e);\r\n      }\r\n    });",
  "sys__UUID": "da696ba4-4545-401f-acf0-3e01e396bc27",
  "sys__createdBy": "ekauser@ekaplus.com"
}

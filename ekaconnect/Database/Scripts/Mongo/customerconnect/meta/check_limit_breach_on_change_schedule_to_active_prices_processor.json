{
  "_id": "check_limit_breach_on_change_schedule_to_active_prices_processor",
  "name": "check_limit_breach_on_change_schedule_to_active_prices_processor",
  "refType": "app",
  "refTypeId": "12325a98-a959-4939-9005-4158d136afcd",
  "snippet": "const appId = '12325a98-a959-4939-9005-4158d136afcd';\r\nconst priceObjId = 'ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40';\r\nconst volumeLimitObjId = 'c98119db-1f7c-4802-b72a-6678f1ecc0f3';\r\nconst procssorName = req.body.processorDetails.name;\r\nvar priceData = req.body.bulkPayLoadData;\r\nvar moment = require('moment');\r\n\r\nvar currentDateTime = moment.utc();\r\n\/\/ console.log('expiryDate:' + expiryDate);\r\nvar connectMetaPrice = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n};\r\nvar connectMetaVolumeLimit = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${volumeLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n};\r\nvar connectDataVolumeLimit = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${volumeLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'limitBreachStatus',\r\n          operator: 'eq',\r\n          value: 'Y',\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar elastic_updatePriceData_UpdateDailyPurchase_internal = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n  body: {\r\n    output: {\r\n      elastic_updatePriceData_UpdateDailyPurchase_internal: [],\r\n    },\r\n    task: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    appId: `${appId}`,\r\n    workflowTaskName: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n  },\r\n  json: true,\r\n};\r\nvar elastic_updatePriceData_UpdateDailyPurchase_internal_schedule = {\r\n  method: 'POST',\r\n  url:\r\n    req.body.propertyList.eka_connect_workflow_utility_host +\r\n    '\/common\/scheduleWorkflowForData',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n  body: {\r\n    output: {\r\n      elastic_updatePriceData_UpdateDailyPurchase_internal: [],\r\n    },\r\n    task: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    appId: `${appId}`,\r\n    workflowTaskName: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    object: `${priceObjId}`,\r\n    schedulerConfig: {\r\n      cronExpression: '',\r\n    },\r\n    disableCheckScheduledInProgress: true,\r\n  },\r\n  json: true,\r\n};\r\n\r\nfunction get_connectData(connectData) {\r\n  return new Promise(function (resolve, reject) {\r\n    console.log('get_connectData Request-' + JSON.stringify(connectData));\r\n    request(connectData, function (err, response, body) {\r\n      \/\/ console.log(\"get_connectData Response-\" + JSON.stringify(body));\r\n      if (response.statusCode === 200) resolve(body);\r\n      else {\r\n        reject(err || body);\r\n      }\r\n    });\r\n  });\r\n}\r\nfunction call_connectWorkflow(connectWorkflow) {\r\n  return new Promise(function (resolve, reject) {\r\n    console.log(\r\n      'call_connectWorkflow Request-' + JSON.stringify(connectWorkflow)\r\n    );\r\n    request(connectWorkflow, function (err, response, body) {\r\n      \/\/ console.log(\"call_connectWorkflow Response-\" + JSON.stringify(body));\r\n      if (response.statusCode === 200) resolve(body);\r\n      else {\r\n        resolve(body);\r\n      }\r\n    });\r\n  });\r\n}\r\nvar offset = 0;\r\nvar currentDateTimeWithTimezone;\r\n(async () => {\r\n  if (priceData && priceData.length > 0) {\r\n    var volumeLimitUniqueFields = JSON.parse(\r\n      await get_connectData(connectMetaVolumeLimit)\r\n    ).uniqueFields;\r\n    volumeLimitUniqueFields = volumeLimitUniqueFields.filter(\r\n      (e) => e != 'site' && e != 'quality'\r\n    );\r\n    volumeLimitUniqueFields.forEach((element) => {\r\n      connectDataVolumeLimit.body.filterData.filter.push({\r\n        fieldName: element,\r\n        operator: 'eq',\r\n        value: priceData[0][element],\r\n      });\r\n    });\r\n    await Promise.all([\r\n      get_connectData(connectDataVolumeLimit),\r\n      get_connectData(connectMetaPrice),\r\n    ])\r\n      .then(async function (result) {\r\n        var volumeLimitData = result[0];\r\n        var priceUniqueFields = JSON.parse(result[1]).uniqueFields;\r\n        var volumeLimitDataResult = volumeLimitData.find(\r\n          (volumeLimitDataEntry) =>\r\n            (volumeLimitDataEntry.site == priceData[0].site &&\r\n              volumeLimitDataEntry.quality == priceData[0].quality) ||\r\n            (volumeLimitDataEntry.site == 'All' &&\r\n              volumeLimitDataEntry.quality == priceData[0].quality) ||\r\n            (volumeLimitDataEntry.site == priceData[0].site &&\r\n              volumeLimitDataEntry.quality == 'All') ||\r\n            (volumeLimitDataEntry.site == 'All' &&\r\n              volumeLimitDataEntry.quality == 'All')\r\n        );\r\n        \/\/ for (let i = 0; i < volumeLimitData.length; i++) {\r\n        if (volumeLimitDataResult) {\r\n          offset = priceData[0].clientTimezoneOffset\r\n            ? priceData[0].clientTimezoneOffset\r\n            : 0;\r\n          currentDateTimeWithTimezone = currentDateTime\r\n            .clone()\r\n            .subtract(offset, 'minutes');\r\n          if (moment.utc(priceData[0].startDateTime) > currentDateTime) {\r\n            priceData[0].startDateTime = currentDateTime.format(\r\n              'YYYY-MM-DDTHH:mm:ss[Z]'\r\n            );\r\n            priceData[0].startDate =\r\n              currentDateTimeWithTimezone.format('YYYY-MM-DD');\r\n            priceData[0].startTime =\r\n              currentDateTimeWithTimezone.format('HH:mm');\r\n          }\r\n          priceData[0].endDateTime = currentDateTime.format(\r\n            'YYYY-MM-DDTHH:mm:ss[Z]'\r\n          );\r\n          priceData[0].endDate =\r\n            currentDateTimeWithTimezone.format('YYYY-MM-DD');\r\n          priceData[0].endTime = currentDateTimeWithTimezone.format('HH:mm');\r\n          elastic_updatePriceData_UpdateDailyPurchase_internal.body.output.elastic_updatePriceData_UpdateDailyPurchase_internal.push(\r\n            priceUniqueFields.reduce(\r\n              (result, item) => ({ ...result, [item]: priceData[0][item] }),\r\n              {\r\n                status: 'Expired',\r\n                startDateTime: priceData[0].startDateTime,\r\n                startDate: priceData[0].startDate,\r\n                startTime: priceData[0].startTime,\r\n                endDateTime: priceData[0].endDateTime,\r\n                endDate: priceData[0].endDate,\r\n                endTime: priceData[0].endTime,\r\n              }\r\n            )\r\n          );\r\n        } else {\r\n          elastic_updatePriceData_UpdateDailyPurchase_internal.body.output.elastic_updatePriceData_UpdateDailyPurchase_internal.push(\r\n            priceUniqueFields.reduce(\r\n              (result, item) => ({ ...result, [item]: priceData[0][item] }),\r\n              {\r\n                status: 'Active',\r\n              }\r\n            )\r\n          );\r\n          elastic_updatePriceData_UpdateDailyPurchase_internal_schedule.body.output.elastic_updatePriceData_UpdateDailyPurchase_internal =\r\n            [\r\n              priceUniqueFields.reduce(\r\n                (result, item) => ({\r\n                  ...result,\r\n                  [item]: priceData[0][item],\r\n                }),\r\n                { status: 'Expired' }\r\n              ),\r\n            ];\r\n\r\n          elastic_updatePriceData_UpdateDailyPurchase_internal_schedule.body.schedulerConfig.cronExpression =\r\n            moment\r\n              .utc(\r\n                priceData[0].endDateTime,\r\n                'YYYY-MM-DDTHH:mm:ss[Z]'\r\n              )\r\n              .format('s m H D M [?] YYYY');\r\n          call_connectWorkflow(\r\n            elastic_updatePriceData_UpdateDailyPurchase_internal_schedule\r\n          ).catch((err) => {\r\n            console.log(err);\r\n            res.status(500).send(err);\r\n          });\r\n\r\n          \/\/   elastic_updatePriceData_UpdateDailyPurchase_internal.body.output.elastic_updatePriceData_internal.push(\r\n          \/\/     priceUniqueFields.reduce(\r\n          \/\/       (result, item) => ({ ...result, [item]: priceData[j][item] }),\r\n          \/\/       {\r\n          \/\/         status: 'Active',\r\n          \/\/       }\r\n          \/\/     )\r\n          \/\/   );\r\n          \/\/   elastic_updatePriceData_UpdateDailyPurchase_internal.body.schedulerConfig.cronExpression =\r\n          \/\/     moment\r\n          \/\/       .utc(\r\n          \/\/         priceData[0].startDateTime,\r\n          \/\/         'YYYY-MM-DDTHH:mm:ss[Z]'\r\n          \/\/       )\r\n          \/\/       .format('s m H D M [?] YYYY');\r\n          \/\/   elastic_updatePriceData_UpdateDailyPurchase_internal.body.url =\r\n          \/\/     req.body.propertyList.eka_connect_workflow_utility_host +\r\n          \/\/     '\/common\/scheduleWorkflowForData';\r\n          \/\/   elastic_updatePriceData_UpdateDailyPurchase_internal.body.object =\r\n          \/\/     priceObjId;\r\n          \/\/   elastic_updatePriceData_UpdateDailyPurchase_internal.body.disableCheckScheduledInProgress = true;\r\n          \/\/ }\r\n        }\r\n        if (\r\n          elastic_updatePriceData_UpdateDailyPurchase_internal.body.output\r\n            .elastic_updatePriceData_UpdateDailyPurchase_internal.length > 0\r\n        )\r\n          await call_connectWorkflow(\r\n            elastic_updatePriceData_UpdateDailyPurchase_internal\r\n          ).catch((err) => {\r\n            console.log(err);\r\n          });\r\n\r\n        res.status(200).send();\r\n      })\r\n      .catch((err) => {\r\n        console.log(err);\r\n        res.status(500).send(err);\r\n      });\r\n  }\r\n})().catch(function (err) {\r\n  console.log(err);\r\n  res.status(500).send(err);\r\n});",
  "sys__UUID": "c3a5f112-4e88-49e0-ac79-d5abc0abf7b0",
  "type": "processor"
}

{
  "_id": "expire_prices_processor",
  "name": "expire_prices_processor",
  "refType": "app",
  "isNode" : true,
  "refTypeId": "12325a98-a959-4939-9005-4158d136afcd",
  "snippet": "const appId = '12325a98-a959-4939-9005-4158d136afcd';\r\nconst priceObjId = 'ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40';\r\nconst procssorName = req.body.processorDetails.name;\r\nvar data = req.body.bulkPayLoadData;\r\nvar moment = require('moment');\r\n\r\nvar currentDateTime = moment.utc();\r\nvar currentDateTimePlusTwoHour = currentDateTime.clone().add(2, 'h');\r\n\/\/ console.log('expiryDate:' + expiryDate);\r\nvar connectMetaPrice = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n};\r\nvar connectDataprice = {\r\n  method: 'GET',\r\n  url: req.body.propertyList.eka_connect_host + `\/data\/${appId}\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'status',\r\n          operator: 'ne',\r\n          value: 'Expired',\r\n        },\r\n        {\r\n          fieldName: 'endDateTime',\r\n          operator: 'lt',\r\n          value: `${currentDateTime.format('YYYY-MM-DDTHH:mm:ss[Z]')}`,\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar elastic_updatePriceData_internal = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n  body: {\r\n    output: {\r\n      elastic_updatePriceData_internal: [],\r\n    },\r\n    task: 'elastic_updatePriceData_internal',\r\n    appId: `${appId}`,\r\n    workflowTaskName: 'elastic_updatePriceData_internal',\r\n  },\r\n  json: true,\r\n};\r\nvar elastic_updatePriceData_UpdateDailyPurchase_internal = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n  body: {\r\n    output: {\r\n      elastic_updatePriceData_UpdateDailyPurchase_internal: [],\r\n    },\r\n    task: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    appId: `${appId}`,\r\n    workflowTaskName: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n  },\r\n  json: true,\r\n};\r\nvar elastic_updatePriceData_UpdateDailyPurchase_internal_schedule = {\r\n  method: 'POST',\r\n  url:\r\n    req.body.propertyList.eka_connect_workflow_utility_host +\r\n    '\/common\/scheduleWorkflowForData',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n  body: {\r\n    output: {\r\n      elastic_updatePriceData_UpdateDailyPurchase_internal: [],\r\n    },\r\n    task: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    appId: `${appId}`,\r\n    workflowTaskName: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    object: `${priceObjId}`,\r\n    schedulerConfig: {\r\n      cronExpression: '',\r\n    },\r\n    disableCheckScheduledInProgress: true,\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar check_limit_breach_on_change_schedule_to_active_prices_internal = {\r\n  method: 'POST',\r\n  url:\r\n    req.body.propertyList.eka_connect_workflow_utility_host +\r\n    '\/common\/scheduleWorkflowForData',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-' + procssorName,\r\n  },\r\n  body: {\r\n    output: {\r\n      check_limit_breach_on_change_schedule_to_active_prices_internal: [],\r\n    },\r\n    task: 'check_limit_breach_on_change_schedule_to_active_prices_internal',\r\n    appId: `${appId}`,\r\n    workflowTaskName:\r\n      'check_limit_breach_on_change_schedule_to_active_prices_internal',\r\n    object: `${priceObjId}`,\r\n    schedulerConfig: {\r\n      cronExpression: '',\r\n    },\r\n    disableCheckScheduledInProgress: true,\r\n  },\r\n  json: true,\r\n};\r\n\r\nfunction get_connectData(connectData) {\r\n  return new Promise(function (resolve, reject) {\r\n    console.log('get_connectData Request-' + JSON.stringify(connectData));\r\n    request(connectData, function (err, response, body) {\r\n      \/\/ console.log(\"get_connectData Response-\" + JSON.stringify(body));\r\n      if (response.statusCode === 200) resolve(body);\r\n      else {\r\n        reject(err || body);\r\n      }\r\n    });\r\n  });\r\n}\r\nfunction call_connectWorkflow(connectWorkflow) {\r\n  return new Promise(function (resolve, reject) {\r\n    console.log(\r\n      'call_connectWorkflow Request-' + JSON.stringify(connectWorkflow)\r\n    );\r\n    request(connectWorkflow, function (err, response, body) {\r\n      \/\/ console.log(\"call_connectWorkflow Response-\" + JSON.stringify(body));\r\n      if (response.statusCode === 200) resolve(body);\r\n      else {\r\n        resolve(body);\r\n      }\r\n    });\r\n  });\r\n}\r\nvar offset = 0;\r\nvar currentDateTimeWithTimezone;\r\n(async () => {\r\n  if (data && data.length > 0)\r\n    await Promise.all([get_connectData(connectMetaPrice)])\r\n      .then(async function (result) {\r\n        var priceToExpireSchedule = data.filter(\r\n          (entry) => entry.status != 'Expired'\r\n          \/\/ &&\r\n          \/\/ moment\r\n          \/\/   .utc(entry.endDateTime, 'YYYY-MM-DDTHH:mm:ss[Z]')\r\n          \/\/   .isSameOrBefore(currentDateTimePlusTwoHour)\r\n        );\r\n        var priceUniqueFields = JSON.parse(result[0]).uniqueFields;\r\n        \/\/ priceUniqueFields.push('startDateTime','startDate','startTime','endDateTime','endDate','endTime');\r\n        for (let j = 0; j < priceToExpireSchedule.length; j++) {\r\n          if (\r\n            moment\r\n              .utc(\r\n                priceToExpireSchedule[j].startDateTime,\r\n                'YYYY-MM-DDTHH:mm:ss[Z]'\r\n              )\r\n              .isSameOrAfter(currentDateTime) &&\r\n            moment\r\n              .utc(\r\n                priceToExpireSchedule[j].startDateTime,\r\n                'YYYY-MM-DDTHH:mm:ss[Z]'\r\n              )\r\n              .isSameOrBefore(currentDateTimePlusTwoHour)\r\n          ) {\r\n            check_limit_breach_on_change_schedule_to_active_prices_internal.body.output.check_limit_breach_on_change_schedule_to_active_prices_internal =\r\n              [priceToExpireSchedule[j]];\r\n\r\n            check_limit_breach_on_change_schedule_to_active_prices_internal.body.schedulerConfig.cronExpression =\r\n              moment\r\n                .utc(\r\n                  priceToExpireSchedule[j].startDateTime,\r\n                  'YYYY-MM-DDTHH:mm:ss[Z]'\r\n                )\r\n                .format('s m H D M [?] YYYY');\r\n            call_connectWorkflow(\r\n              check_limit_breach_on_change_schedule_to_active_prices_internal\r\n            ).catch((err) => {\r\n              console.log(err);\r\n              res.status(500).send(err);\r\n            });\r\n          } else if (\r\n            moment\r\n              .utc(\r\n                priceToExpireSchedule[j].startDateTime,\r\n                'YYYY-MM-DDTHH:mm:ss[Z]'\r\n              )\r\n              .isSameOrBefore(currentDateTime) &&\r\n            moment\r\n              .utc(\r\n                priceToExpireSchedule[j].endDateTime,\r\n                'YYYY-MM-DDTHH:mm:ss[Z]'\r\n              )\r\n              .isSameOrBefore(currentDateTimePlusTwoHour)\r\n          ) {\r\n            elastic_updatePriceData_UpdateDailyPurchase_internal_schedule.body.output.elastic_updatePriceData_UpdateDailyPurchase_internal =\r\n              [\r\n                priceUniqueFields.reduce(\r\n                  (result, item) => ({\r\n                    ...result,\r\n                    [item]: priceToExpireSchedule[j][item],\r\n                  }),\r\n                  { status: 'Expired' }\r\n                ),\r\n              ];\r\n\r\n            elastic_updatePriceData_UpdateDailyPurchase_internal_schedule.body.schedulerConfig.cronExpression =\r\n              moment\r\n                .utc(\r\n                  priceToExpireSchedule[j].endDateTime,\r\n                  'YYYY-MM-DDTHH:mm:ss[Z]'\r\n                )\r\n                .format('s m H D M [?] YYYY');\r\n            call_connectWorkflow(\r\n              elastic_updatePriceData_UpdateDailyPurchase_internal_schedule\r\n            ).catch((err) => {\r\n              console.log(err);\r\n              res.status(500).send(err);\r\n            });\r\n          }\r\n        }\r\n\r\n        res.status(200).send();\r\n      })\r\n      .catch((err) => {\r\n        console.log(err);\r\n        res.status(500).send(err);\r\n      });\r\n  else\r\n    await Promise.all([\r\n      get_connectData(connectDataprice),\r\n      get_connectData(connectMetaPrice),\r\n    ])\r\n      .then(async function (result) {\r\n        var priceData = result[0];\r\n        var priceUniqueFields = JSON.parse(result[1]).uniqueFields;\r\n        \/\/ priceUniqueFields.clo.push('startDateTime','startDate','startTime','endDateTime','endDate','endTime');\r\n        for (let j = 0; j < priceData.length; j++) {\r\n          elastic_updatePriceData_UpdateDailyPurchase_internal.body.output.elastic_updatePriceData_UpdateDailyPurchase_internal.push(\r\n            priceUniqueFields.reduce(\r\n              (result, item) => ({ ...result, [item]: priceData[j][item] }),\r\n              {\r\n                status: 'Expired',\r\n              }\r\n            )\r\n          );\r\n        }\r\n        if (\r\n          elastic_updatePriceData_UpdateDailyPurchase_internal.body.output\r\n            .elastic_updatePriceData_UpdateDailyPurchase_internal.length > 0\r\n        )\r\n          await call_connectWorkflow(\r\n            elastic_updatePriceData_UpdateDailyPurchase_internal\r\n          ).catch((err) => {\r\n            console.log(err);\r\n          });\r\n\r\n        \/\/Schedule active prices to get expired which are supposed to get expired in next 2 hours\r\n        connectDataprice.body.filterData.filter = [\r\n          {\r\n            fieldName: 'status',\r\n            operator: 'ne',\r\n            value: 'Expired',\r\n          },\r\n          {\r\n            fieldName: 'startDateTime',\r\n            operator: 'lt',\r\n            value: `${currentDateTime.format('YYYY-MM-DDTHH:mm:ss[Z]')}`,\r\n          },\r\n          {\r\n            fieldName: 'endDateTime',\r\n            operator: 'lt',\r\n            value: `${currentDateTimePlusTwoHour.format(\r\n              'YYYY-MM-DDTHH:mm:ss[Z]'\r\n            )}`,\r\n          },\r\n        ];\r\n        await get_connectData(connectDataprice)\r\n          .then((priceToExpireSchedule) => {\r\n            for (let j = 0; j < priceToExpireSchedule.length; j++) {\r\n              elastic_updatePriceData_UpdateDailyPurchase_internal_schedule.body.output.elastic_updatePriceData_UpdateDailyPurchase_internal =\r\n                [\r\n                  priceUniqueFields.reduce(\r\n                    (result, item) => ({\r\n                      ...result,\r\n                      [item]: priceToExpireSchedule[j][item],\r\n                    }),\r\n                    { status: 'Expired' }\r\n                  ),\r\n                ];\r\n\r\n              elastic_updatePriceData_UpdateDailyPurchase_internal_schedule.body.schedulerConfig.cronExpression =\r\n                moment\r\n                  .utc(\r\n                    priceToExpireSchedule[j].endDateTime,\r\n                    'YYYY-MM-DDTHH:mm:ss[Z]'\r\n                  )\r\n                  .format('s m H D M [?] YYYY');\r\n              call_connectWorkflow(\r\n                elastic_updatePriceData_UpdateDailyPurchase_internal_schedule\r\n              ).catch((err) => {\r\n                console.log(err);\r\n                res.status(500).send(err);\r\n              });\r\n            }\r\n          })\r\n          .catch((err) => {\r\n            console.log(err);\r\n            res.status(500).send(err);\r\n          });\r\n        connectDataprice.body.filterData.filter = [\r\n          {\r\n            fieldName: 'status',\r\n            operator: 'ne',\r\n            value: 'Expired',\r\n          },\r\n          {\r\n            fieldName: 'startDateTime',\r\n            operator: 'gt',\r\n            value: `${currentDateTime.format('YYYY-MM-DDTHH:mm:ss[Z]')}`,\r\n          },\r\n          {\r\n            fieldName: 'endtDateTime',\r\n            operator: 'lt',\r\n            value: `${currentDateTimePlusTwoHour.format(\r\n              'YYYY-MM-DDTHH:mm:ss[Z]'\r\n            )}`,\r\n          },\r\n        ];\r\n\r\n        \/\/Schedule scheduled prices to either get expired or become active which are supposed to get expired\/active in next 2 hours\r\n        await get_connectData(connectDataprice)\r\n          .then((priceToExpireSchedule) => {\r\n            for (let j = 0; j < priceToExpireSchedule.length; j++) {\r\n              check_limit_breach_on_change_schedule_to_active_prices_internal.body.output.check_limit_breach_on_change_schedule_to_active_prices_internal =\r\n                [priceToExpireSchedule];\r\n\r\n              check_limit_breach_on_change_schedule_to_active_prices_internal.body.schedulerConfig.cronExpression =\r\n                moment\r\n                  .utc(\r\n                    priceToExpireSchedule[j].startDateTime,\r\n                    'YYYY-MM-DDTHH:mm:ss[Z]'\r\n                  )\r\n                  .format('s m H D M [?] YYYY');\r\n              call_connectWorkflow(\r\n                check_limit_breach_on_change_schedule_to_active_prices_internal\r\n              ).catch((err) => {\r\n                console.log(err);\r\n                res.status(500).send(err);\r\n              });\r\n            }\r\n          })\r\n          .catch((err) => {\r\n            console.log(err);\r\n            res.status(500).send(err);\r\n          });\r\n        res.status(200).send();\r\n      })\r\n      .catch((err) => {\r\n        console.log(err);\r\n        res.status(500).send(err);\r\n      });\r\n})().catch(function (err) {\r\n  console.log(err);\r\n  res.status(500).send(err);\r\n});",
  "sys__UUID": "4bbfe14a-4470-43c3-afaf-a00c21c93aeb",
  "type": "processor"
}

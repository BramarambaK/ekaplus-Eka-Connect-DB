{
  "_id": "fetch_offers_to_execute_processor",
  "name": "fetch_offers_to_execute_processor",
  "refType": "app",
  "refTypeId": "12325a98-a959-4939-9005-4158d136afcd",
  "snippet" : "const appId = '12325a98-a959-4939-9005-4158d136afcd';\r\nconst ticketOfferObjId = 'a26737b3-a5a9-4fe9-b6f7-29218a3bc45a';\r\nconst contractOfferObjId = '46e84f42-6288-4027-b6d0-fd1c11019259';\r\nconst priceObjId = 'ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40';\r\nconst volumeLimitObjId = 'c98119db-1f7c-4802-b72a-6678f1ecc0f3';\r\nconst offerForWarehousedTickets = 'Offer for warehoused tickets';\r\nconst offerToSell = 'Offer to sell';\r\nconst traderName = req.body.propertyList.REQ_CONTRACTS_TRADER_NAME;\r\n\r\nconst priceUnit = req.body.propertyList.REQ_CONTRACTS_PRICE_UNIT;\r\nconst weightUnit = req.body.propertyList.REQ_CONTRACTS_WEIGHT_UNIT;\r\nconst corporate = req.body.propertyList.REQ_CONTRACTS_CORPORATE;\r\nconst createdBy = req.body.propertyList._REQ_CONTRACTS_CREATED_BY;\r\nconst operator = req.body.propertyList._REQ_CONTRACTS_OPERATOR;\r\n\r\nvar moment = require('moment');\r\nvar currentDateTime;\r\n\r\nvar payloadDataUnfiltered;\r\n\/\/Format payload into object array\r\nif (!Array.isArray(req.body.bulkPayLoadData)) {\r\n  payloadDataUnfiltered = [{ ...req.body }];\r\n  delete payloadDataUnfiltered[0]['processorDetails'];\r\n  delete payloadDataUnfiltered[0]['propertyList'];\r\n} else {\r\n  payloadDataUnfiltered = req.body.bulkPayLoadData;\r\n}\r\n\r\nvar payloadDataFiltered;\r\n\/\/Execute ticket offers during offer creation\r\nif (\r\n  payloadDataUnfiltered[0].object == ticketOfferObjId &&\r\n  payloadDataUnfiltered[0].requestType == offerForWarehousedTickets\r\n) {\r\n  payloadDataFiltered = payloadDataUnfiltered.filter(\r\n    (o) =>\r\n      o.cropYear &&\r\n      o.product &&\r\n      o.quality &&\r\n      o.location &&\r\n      o.ticketHandlerCode &&\r\n      o.isRequestedByEkaCCSystem &&\r\n      o.requestType == offerForWarehousedTickets &&\r\n      o.requestStatus == 'Awaiting review'\r\n  );\r\n}\r\n\/\/Execute contract offers during offer creation\r\nelse if (\r\n  payloadDataUnfiltered[0].object == contractOfferObjId &&\r\n  payloadDataUnfiltered[0].requestType == offerToSell\r\n) {\r\n  payloadDataFiltered = payloadDataUnfiltered.filter(\r\n    (o) =>\r\n      o.cropYear &&\r\n      o.product &&\r\n      o.quality &&\r\n      o.offersite &&\r\n      o.INCOTerm &&\r\n      o.dischargeLocationCity &&\r\n      o.isRequestedByEkaCCSystem &&\r\n      o.offersustainable != undefined &&\r\n      o.offersustainable != null &&\r\n      o.requestType == offerToSell &&\r\n      o.approvalStatus == 'Awaiting review' &&\r\n      ((o.INCOTerm == 'DB' && o.shipmentPeriodFrom && o.shipmentPeriodTo) ||\r\n        o.INCOTerm != 'DB')\r\n  );\r\n}\r\n\/\/Execute ticket offers during change in dailyLimit for volumeLimit object\r\nelse if (\r\n  payloadDataUnfiltered[0].object == volumeLimitObjId \/\/&& payloadDataUnfiltered.filter((o) => o.hasOwnProperty(\"dailyLimit\")).length > 0\r\n) {\r\n  payloadDataFiltered = payloadDataUnfiltered.filter(\r\n    (o) =>\r\n      o.hasOwnProperty('dailyLimit') &&\r\n      o.season &&\r\n      o.product &&\r\n      o.quality &&\r\n      o.site &&\r\n      o.bpExternalCode &&\r\n      o.site\r\n    \/\/ && o.marketType\r\n  );\r\n}\r\n\/\/Execute ticket offers during change in price for price object\r\nelse if (\r\n  payloadDataUnfiltered[0].object == priceObjId \/\/&&\r\n  \/\/payloadDataUnfiltered.filter((o) => o.hasOwnProperty(\"price\")).length > 0\r\n) {\r\n  payloadDataFiltered = payloadDataUnfiltered.filter(\r\n    (o) =>\r\n      o.hasOwnProperty('price') &&\r\n      o.status != 'Expired' &&\r\n      o.season &&\r\n      o.product &&\r\n      o.quality &&\r\n      o.site &&\r\n      o.bpExternalCode &&\r\n      o.site &&\r\n      o.marketType\r\n  );\r\n}\r\nconsole.log(payloadDataFiltered);\r\nvar gcs_allocateTicket = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-processor',\r\n  },\r\n  body: {\r\n    output: {\r\n      EXTERNAL_GCS_ALLOCATE_TICKETS: [],\r\n    },\r\n    task: 'EXTERNAL_GCS_ALLOCATE_TICKETS',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName: 'EXTERNAL_GCS_ALLOCATE_TICKETS',\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar elastic_updateTicketOfferData_withoutOfferExecution_internal = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-processor',\r\n  },\r\n  body: {\r\n    output: {\r\n      elastic_updateTicketOfferData_withoutOfferExecution_internal: [],\r\n    },\r\n    task: 'elastic_updateTicketOfferData_withoutOfferExecution_internal',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName:\r\n      'elastic_updateTicketOfferData_withoutOfferExecution_internal',\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar EXT_NOTIFICATION_OFFER_FOR_CONTRACT_APPROVED = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-processor',\r\n  },\r\n  body: {\r\n    output: {\r\n      EXT_NOTIFICATION_OFFER_FOR_CONTRACT_APPROVED: [],\r\n    },\r\n    task: 'EXT_NOTIFICATION_OFFER_FOR_CONTRACT_APPROVED',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName: 'EXT_NOTIFICATION_OFFER_FOR_CONTRACT_APPROVED',\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'] + '-processor',\r\n  },\r\n  body: {\r\n    output: {\r\n      EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD: [],\r\n    },\r\n    task: 'EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName: 'EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD',\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectMetaTicketOffer = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${ticketOfferObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n};\r\nvar connectMetaContractOffer = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${contractOfferObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n};\r\nvar connectMetaPrice = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n};\r\nvar connectMetaVolumeLimit = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${volumeLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n};\r\n\r\nvar connectDataTicketOffer = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${ticketOfferObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {},\r\n  json: true,\r\n};\r\nvar connectDataContractOffer = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${contractOfferObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {},\r\n  json: true,\r\n};\r\n\r\nvar connectDataPrice = {\r\n  method: 'GET',\r\n  url: req.body.propertyList.eka_connect_host + `\/data\/${appId}\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {},\r\n  json: true,\r\n};\r\n\r\nvar connectDataVolumeLimit = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${volumeLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {},\r\n  json: true,\r\n};\r\n\r\nvar get_programName = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + `\/workflow`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    output: {\r\n      get_programName: [],\r\n    },\r\n    task: 'get_programName',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName: 'get_programName',\r\n  },\r\n  json: true,\r\n};\r\nvar call_ctrmContractInboundAPI = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + `\/workflow`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    output: {\r\n      EXTERNAL_CTRM_CONTRACT_INBOUND_API: {},\r\n    },\r\n    task: 'EXTERNAL_CTRM_CONTRACT_INBOUND_API',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName: 'EXTERNAL_CTRM_CONTRACT_INBOUND_API',\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar call_update_contractDomainData = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + `\/workflow`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    output: {\r\n      update_contractDomainData: [],\r\n    },\r\n    task: 'update_contractDomainData',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName: 'update_contractDomainData',\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar call_delete_contractDomainData = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + `\/workflow`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    output: {\r\n      delete_contractDomainData: [],\r\n    },\r\n    task: 'delete_contractDomainData',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName: 'delete_contractDomainData',\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar elastic_updateVolumeLimitData_UpdateDailyPurchase_internal = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + `\/workflow`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    output: {\r\n      elastic_updateVolumeLimitData_UpdateDailyPurchase_internal: [],\r\n    },\r\n    task: 'elastic_updateVolumeLimitData_UpdateDailyPurchase_internal',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName:\r\n      'elastic_updateVolumeLimitData_UpdateDailyPurchase_internal',\r\n  },\r\n  json: true,\r\n};\r\nvar elastic_updatePriceData_UpdateDailyPurchase_internal = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + `\/workflow`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    output: {\r\n      elastic_updatePriceData_UpdateDailyPurchase_internal: [],\r\n    },\r\n    task: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    appId: '12325a98-a959-4939-9005-4158d136afcd',\r\n    workflowTaskName: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n  },\r\n  json: true,\r\n};\r\nvar connectDataPatchTicketOffer = {\r\n  method: 'PATCH',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${ticketOfferObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [],\r\n    },\r\n    payload: {},\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectDataPatchContractOffer = {\r\n  method: 'PATCH',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${contractOfferObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [],\r\n    },\r\n    payload: {},\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectDataPatchPrice = {\r\n  method: 'PATCH',\r\n  url: req.body.propertyList.eka_connect_host + `\/data\/${appId}\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [],\r\n    },\r\n    payload: {},\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectDataPatchVolumeLimit = {\r\n  method: 'PATCH',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${volumeLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [],\r\n    },\r\n    payload: {},\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectGetSystemAccessToken = {\r\n  method: 'PATCH',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${volumeLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [],\r\n    },\r\n    payload: {},\r\n  },\r\n  json: true,\r\n};\r\nfunction get_connectMeta(connectData) {\r\n  return new Promise(function (resolve, reject) {\r\n    \/\/   console.log(\"get_connectData Request-\" + JSON.stringify(connectData));\r\n    request(connectData, function (err, response, body) {\r\n      \/\/   console.log(\"get_connectData Response-\" + JSON.stringify(body));\r\n      if (response.statusCode === 200) resolve(body);\r\n      else {\r\n        reject(err || body);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction get_connectData(connectData) {\r\n  return new Promise(function (resolve, reject) {\r\n    console.log('get_connectData Request-' + JSON.stringify(connectData));\r\n    request(connectData, function (err, response, body) {\r\n      console.log('get_connectData Response-' + JSON.stringify(body));\r\n      if (response.statusCode === 200) resolve(body);\r\n      else {\r\n        reject(err || body);\r\n      }\r\n    });\r\n  });\r\n}\r\nfunction call_connectWorkflow(connectWorkflow) {\r\n  return new Promise(function (resolve, reject) {\r\n    console.log(\r\n      'call_connectWorkflow Request-' + JSON.stringify(connectWorkflow)\r\n    );\r\n    request(connectWorkflow, function (err, response, body) {\r\n      console.log('call_connectWorkflow Response-' + JSON.stringify(body));\r\n      if (response.statusCode === 200) resolve(body);\r\n      else {\r\n        reject(err || body);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n\/\/This method unlocks ticketOffer price volumeLimit by passing parameter (true\/false)\r\nfunction unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n  unlockTicketOffer,\r\n  unlockContractOffer,\r\n  unlockPrice,\r\n  unlockVolumeLimit\r\n) {\r\n  console.log('Running unlock_ticketOffer_contractOffer_price_volumeLimit');\r\n  if (\r\n    unlockTicketOffer &&\r\n    connectDataPatchTicketOffer.body.filterData.filter.length > 0\r\n  ) {\r\n    connectDataPatchTicketOffer.body.filterData.filter.forEach((e) => {\r\n      if (e.fieldName == 'isProcessing') e.operator = 'eq';\r\n    });\r\n    connectDataPatchTicketOffer.body.payload = { isProcessing: false };\r\n    get_connectData(connectDataPatchTicketOffer);\r\n  }\r\n  if (\r\n    unlockContractOffer &&\r\n    connectDataPatchContractOffer.body.filterData.filter.length > 0\r\n  ) {\r\n    connectDataPatchContractOffer.body.filterData.filter.forEach((e) => {\r\n      if (e.fieldName == 'isProcessing') e.operator = 'eq';\r\n    });\r\n    connectDataPatchContractOffer.body.payload = { isProcessing: false };\r\n    get_connectData(connectDataPatchContractOffer);\r\n  }\r\n  if (unlockPrice && connectDataPatchPrice.body.filterData.filter.length > 0) {\r\n    connectDataPatchPrice.body.filterData.filter.forEach((e) => {\r\n      if (e.fieldName == 'isProcessing') e.operator = 'eq';\r\n    });\r\n    connectDataPatchPrice.body.payload = { isProcessing: false };\r\n    get_connectData(connectDataPatchPrice);\r\n  }\r\n  if (\r\n    unlockVolumeLimit &&\r\n    connectDataPatchVolumeLimit.body.filterData.filter.length > 0\r\n  ) {\r\n    connectDataPatchVolumeLimit.body.filterData.filter.forEach((e) => {\r\n      if (e.fieldName == 'isProcessing') e.operator = 'eq';\r\n    });\r\n    connectDataPatchVolumeLimit.body.payload = { isProcessing: false };\r\n    get_connectData(connectDataPatchVolumeLimit);\r\n  }\r\n}\r\n\r\n\/\/This method add proper filters To fetch OfferTicket, VolumeLimit and Price\r\nfunction addFilterToFetchOfferTicketVolumeLimitPrice(payloadDataRecord) {\r\n  console.log('Running addFilterToFetchOfferTicketVolumeLimitPrice');\r\n  \/\/TicketOffer\r\n  connectDataTicketOffer.body = {\r\n    getLatestData: true,\r\n    sort: { requestDate: 'asc' },\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'cropYear',\r\n          operator: 'eq',\r\n          value:\r\n            payloadDataRecord.object == ticketOfferObjId\r\n              ? payloadDataRecord.cropYear\r\n              : payloadDataRecord.season,\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.product,\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.quality,\r\n        },\r\n        {\r\n          fieldName: 'location',\r\n          operator: 'eq',\r\n          value:\r\n            payloadDataRecord.object == ticketOfferObjId\r\n              ? payloadDataRecord.location\r\n              : payloadDataRecord.site,\r\n        },\r\n        {\r\n          fieldName: 'ticketHandlerCode',\r\n          operator: 'eq',\r\n          value:\r\n            payloadDataRecord.object == ticketOfferObjId\r\n              ? payloadDataRecord.ticketHandlerCode\r\n              : payloadDataRecord.bpExternalCode,\r\n        },\r\n        {\r\n          fieldName: 'offerPrice',\r\n          operator: 'lte',\r\n          value: '',\r\n        },\r\n        {\r\n          fieldName: 'quantity',\r\n          operator: 'lte',\r\n          value: '',\r\n        },\r\n        {\r\n          fieldName: 'ticketRefNo',\r\n          operator: 'nin',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'requestType',\r\n          operator: 'eq',\r\n          value: 'Offer for warehoused tickets',\r\n        },\r\n        {\r\n          fieldName: 'isRequestedByEkaCCSystem',\r\n          operator: 'eq',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'requestStatus',\r\n          operator: 'eq',\r\n          value: 'Awaiting review',\r\n        },\r\n        {\r\n          fieldName: 'isProcessing',\r\n          operator: 'ne',\r\n          value: true,\r\n        },\r\n      ],\r\n    },\r\n  };\r\n  \/\/Price\r\n  connectDataPrice.body = {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'season',\r\n          operator: 'eq',\r\n          value:\r\n            payloadDataRecord.object == ticketOfferObjId\r\n              ? payloadDataRecord.cropYear\r\n              : payloadDataRecord.season,\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.product,\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.quality,\r\n        },\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'eq',\r\n          value:\r\n            payloadDataRecord.object == ticketOfferObjId\r\n              ? payloadDataRecord.location\r\n              : payloadDataRecord.site,\r\n        },\r\n        {\r\n          fieldName: 'bpExternalCode',\r\n          operator: 'eq',\r\n          value:\r\n            payloadDataRecord.object == ticketOfferObjId\r\n              ? payloadDataRecord.ticketHandlerCode\r\n              : payloadDataRecord.bpExternalCode,\r\n        },\r\n        {\r\n          fieldName: 'startDateTime',\r\n          operator: 'lte',\r\n          value: currentDateTime,\r\n        },\r\n        {\r\n          fieldName: 'endDateTime',\r\n          operator: 'gte',\r\n          value: currentDateTime,\r\n        },\r\n        {\r\n          fieldName: 'status',\r\n          operator: 'ne',\r\n          value: 'Expired',\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Cash',\r\n        },\r\n        {\r\n          fieldName: 'isProcessing',\r\n          operator: 'ne',\r\n          value: true,\r\n        },\r\n      ],\r\n    },\r\n  };\r\n  if (payloadDataRecord.object == volumeLimitObjId) {\r\n    if (payloadDataRecord.quality == 'All' || payloadDataRecord.site == 'All') {\r\n      connectDataPrice.body.filterData.filter =\r\n        connectDataPrice.body.filterData.filter.filter(\r\n          (o) =>\r\n            !(o.fieldName == 'quality' && o.value == 'All') &&\r\n            !(o.fieldName == 'site' && o.value == 'All')\r\n        );\r\n    }\r\n  }\r\n  \/\/VolumeLimit\r\n  connectDataVolumeLimit.body = {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'season',\r\n          operator: 'eq',\r\n          value:\r\n            payloadDataRecord.object == ticketOfferObjId\r\n              ? payloadDataRecord.cropYear\r\n              : payloadDataRecord.season,\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.product,\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'in',\r\n          value: ['All', payloadDataRecord.quality],\r\n        },\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'in',\r\n          value: [\r\n            'All',\r\n            payloadDataRecord.object == ticketOfferObjId\r\n              ? payloadDataRecord.location\r\n              : payloadDataRecord.site,\r\n          ],\r\n        },\r\n        {\r\n          fieldName: 'bpExternalCode',\r\n          operator: 'eq',\r\n          value:\r\n            payloadDataRecord.object == ticketOfferObjId\r\n              ? payloadDataRecord.ticketHandlerCode\r\n              : payloadDataRecord.bpExternalCode,\r\n        },\r\n        {\r\n          fieldName: 'isProcessing',\r\n          operator: 'ne',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'nin',\r\n          value: ['Contract', 'Delivered'],\r\n        },\r\n      ],\r\n    },\r\n  };\r\n  \/\/ if (payloadDataRecord.object == priceObjId) {\r\n  \/\/   connectDataVolumeLimit.body.filterData.filter;\r\n  \/\/ }\r\n}\r\n\/\/This method add proper filters To fetch OfferContract, VolumeLimit and Price\r\nfunction addFilterToFetchOfferContractVolumeLimitPrice(payloadDataRecord) {\r\n  console.log('Running addFilterToFetchOfferContractVolumeLimitPrice');\r\n  if (payloadDataRecord.object == contractOfferObjId) {\r\n    \/\/ContractOffer\r\n    connectDataContractOffer.body = {\r\n      getLatestData: true,\r\n      sort: { requestDateUTC: 'asc' },\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'cropYear',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.cropYear,\r\n          },\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.product,\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.quality,\r\n          },\r\n          {\r\n            fieldName: 'contractPrice',\r\n            operator: 'lte',\r\n            value: '',\r\n          },\r\n          {\r\n            fieldName: 'contractItemQuantity',\r\n            operator: 'lte',\r\n            value: '',\r\n          },\r\n          {\r\n            fieldName: 'requestIdUnique',\r\n            operator: 'nin',\r\n            value: [],\r\n          },\r\n          {\r\n            fieldName: 'requestType',\r\n            operator: 'eq',\r\n            value: 'Offer to sell',\r\n          },\r\n          {\r\n            fieldName: 'isRequestedByEkaCCSystem',\r\n            operator: 'eq',\r\n            value: true,\r\n          },\r\n          {\r\n            fieldName: 'approvalStatus',\r\n            operator: 'eq',\r\n            value: 'Awaiting review',\r\n          },\r\n          {\r\n            fieldName: 'isProcessing',\r\n            operator: 'ne',\r\n            value: true,\r\n          },\r\n          {\r\n            fieldName: 'offersustainable',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.offersustainable,\r\n          },\r\n        ],\r\n      },\r\n    };\r\n    \/\/Price\r\n    connectDataPrice.body = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.cropYear,\r\n          },\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.product,\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.quality,\r\n          },\r\n          {\r\n            fieldName: 'sustainable',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.offersustainable,\r\n          },\r\n          {\r\n            fieldName: 'startDateTime',\r\n            operator: 'lte',\r\n            value: currentDateTime,\r\n          },\r\n          {\r\n            fieldName: 'endDateTime',\r\n            operator: 'gte',\r\n            value: currentDateTime,\r\n          },\r\n          {\r\n            fieldName: 'status',\r\n            operator: 'ne',\r\n            value: 'Expired',\r\n          },\r\n          {\r\n            fieldName: 'isProcessing',\r\n            operator: 'ne',\r\n            value: true,\r\n          },\r\n        ],\r\n      },\r\n    };\r\n    if (payloadDataRecord.object == volumeLimitObjId) {\r\n      if (\r\n        payloadDataRecord.quality == 'All' ||\r\n        payloadDataRecord.site == 'All'\r\n      ) {\r\n        connectDataPrice.body.filterData.filter =\r\n          connectDataPrice.body.filterData.filter.filter(\r\n            (o) =>\r\n              !(o.fieldName == 'quality' && o.value == 'All') &&\r\n              !(o.fieldName == 'site' && o.value == 'All')\r\n          );\r\n      }\r\n    }\r\n    \/\/VolumeLimit\r\n    connectDataVolumeLimit.body = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.cropYear,\r\n          },\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.product,\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'in',\r\n            value: ['All', payloadDataRecord.quality],\r\n          },\r\n          {\r\n            fieldName: 'isProcessing',\r\n            operator: 'ne',\r\n            value: true,\r\n          },\r\n        ],\r\n      },\r\n    };\r\n    if (\r\n      payloadDataRecord.INCOTerm == 'DB' &&\r\n      payloadDataRecord.offersite.match(\/.*(Zone).*\/) == null\r\n    ) {\r\n      \/\/Price\r\n      connectDataPrice.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.offersite,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Delivered',\r\n        },\r\n        {\r\n          fieldName: 'deliveryStartDate',\r\n          operator: 'lte',\r\n          value: payloadDataRecord.shipmentPeriodFrom,\r\n        },\r\n        {\r\n          fieldName: 'deliveryEndDate',\r\n          operator: 'gte',\r\n          value: payloadDataRecord.shipmentPeriodTo,\r\n        }\r\n      );\r\n      \/\/VolumeLimit\r\n      connectDataVolumeLimit.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'in',\r\n          value: ['All', payloadDataRecord.offersite],\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Delivered',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'offersite',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.offersite,\r\n        },\r\n        {\r\n          fieldName: 'shipmentPeriodFrom',\r\n          operator: 'gte',\r\n          value: payloadDataRecord.shipmentPeriodFrom,\r\n        },\r\n        {\r\n          fieldName: 'shipmentPeriodTo',\r\n          operator: 'lte',\r\n          value: payloadDataRecord.shipmentPeriodTo,\r\n        }\r\n      );\r\n    } else if (\r\n      payloadDataRecord.INCOTerm == 'DB' &&\r\n      payloadDataRecord.offersite.match(\/.*(Zone).*\/) != null\r\n    ) {\r\n      \/\/Price\r\n      connectDataPrice.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.dischargeLocationCity,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Delivered',\r\n        },\r\n        {\r\n          fieldName: 'deliveryStartDate',\r\n          operator: 'lte',\r\n          value: payloadDataRecord.shipmentPeriodFrom,\r\n        },\r\n        {\r\n          fieldName: 'deliveryEndDate',\r\n          operator: 'gte',\r\n          value: payloadDataRecord.shipmentPeriodTo,\r\n        }\r\n      );\r\n      \/\/VolumeLimit\r\n      connectDataVolumeLimit.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.dischargeLocationCity,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Delivered',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'dischargeLocationCity',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.dischargeLocationCity,\r\n        },\r\n        {\r\n          fieldName: 'shipmentPeriodFrom',\r\n          operator: 'gte',\r\n          value: payloadDataRecord.shipmentPeriodFrom,\r\n        },\r\n        {\r\n          fieldName: 'shipmentPeriodTo',\r\n          operator: 'lte',\r\n          value: payloadDataRecord.shipmentPeriodTo,\r\n        }\r\n      );\r\n    } else if (\r\n      payloadDataRecord.INCOTerm != 'DB' &&\r\n      payloadDataRecord.offersite.match(\/.*(Zone).*\/) == null\r\n    ) {\r\n      \/\/Price\r\n      connectDataPrice.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.offersite,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Contract',\r\n        }\r\n      );\r\n      \/\/VolumeLimit\r\n      connectDataVolumeLimit.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'in',\r\n          value: ['All', payloadDataRecord.offersite],\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Contract',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push({\r\n        fieldName: 'offersite',\r\n        operator: 'eq',\r\n        value: payloadDataRecord.offersite,\r\n      });\r\n    } else if (\r\n      payloadDataRecord.INCOTerm != 'DB' &&\r\n      payloadDataRecord.offersite.match(\/.*(Zone).*\/) != null\r\n    ) {\r\n      \/\/Price\r\n      connectDataPrice.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.dischargeLocationCity,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Contract',\r\n        }\r\n      );\r\n      \/\/VolumeLimit\r\n      connectDataVolumeLimit.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.dischargeLocationCity,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Contract',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push({\r\n        fieldName: 'dischargeLocationCity',\r\n        operator: 'eq',\r\n        value: payloadDataRecord.dischargeLocationCity,\r\n      });\r\n    }\r\n  } else if (payloadDataRecord.object == priceObjId) {\r\n    \/\/ContractOffer\r\n    connectDataContractOffer.body = {\r\n      getLatestData: true,\r\n      sort: { requestDateUTC: 'asc' },\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'cropYear',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.season,\r\n          },\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.product,\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.quality,\r\n          },\r\n          {\r\n            fieldName: 'contractPrice',\r\n            operator: 'lte',\r\n            value: '',\r\n          },\r\n          {\r\n            fieldName: 'contractItemQuantity',\r\n            operator: 'lte',\r\n            value: '',\r\n          },\r\n          {\r\n            fieldName: 'requestIdUnique',\r\n            operator: 'nin',\r\n            value: [],\r\n          },\r\n          {\r\n            fieldName: 'requestType',\r\n            operator: 'eq',\r\n            value: 'Offer to sell',\r\n          },\r\n          {\r\n            fieldName: 'isRequestedByEkaCCSystem',\r\n            operator: 'eq',\r\n            value: true,\r\n          },\r\n          {\r\n            fieldName: 'approvalStatus',\r\n            operator: 'eq',\r\n            value: 'Awaiting review',\r\n          },\r\n          {\r\n            fieldName: 'isProcessing',\r\n            operator: 'ne',\r\n            value: true,\r\n          },\r\n          {\r\n            fieldName: 'offersustainable',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.sustainable,\r\n          },\r\n        ],\r\n      },\r\n    };\r\n    \/\/Price\r\n    connectDataPrice.body = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'startDateTime',\r\n            operator: 'lte',\r\n            value: currentDateTime,\r\n          },\r\n          {\r\n            fieldName: 'endDateTime',\r\n            operator: 'gte',\r\n            value: currentDateTime,\r\n          },\r\n          {\r\n            fieldName: 'status',\r\n            operator: 'ne',\r\n            value: 'Expired',\r\n          },\r\n          {\r\n            fieldName: 'isProcessing',\r\n            operator: 'ne',\r\n            value: true,\r\n          },\r\n        ],\r\n      },\r\n    };\r\n    priceUniqueFields.forEach((element) => {\r\n      connectDataPrice.body.filterData.filter.push({\r\n        fieldName: element,\r\n        operator: 'eq',\r\n        value: payloadDataRecord[element],\r\n      });\r\n    });\r\n\r\n    \/\/VolumeLimit\r\n    connectDataVolumeLimit.body = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.season,\r\n          },\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.product,\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.quality,\r\n          },\r\n          {\r\n            fieldName: 'isProcessing',\r\n            operator: 'ne',\r\n            value: true,\r\n          },\r\n        ],\r\n      },\r\n    };\r\n    if (\r\n      payloadDataRecord.paymentTerm == 'DB' &&\r\n      payloadDataRecord.region.match(\/.*(Zone).*\/) == null\r\n    ) {\r\n      \/\/VolumeLimit\r\n      connectDataVolumeLimit.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.offersite,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Delivered',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'offersite',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.site,\r\n        },\r\n        {\r\n          fieldName: 'shipmentPeriodFrom',\r\n          operator: 'gte',\r\n          value: payloadDataRecord.deliveryStartDate,\r\n        },\r\n        {\r\n          fieldName: 'shipmentPeriodTo',\r\n          operator: 'lte',\r\n          value: payloadDataRecord.deliveryEndDate,\r\n        }\r\n      );\r\n    } else if (\r\n      payloadDataRecord.paymentTerm == 'DB' &&\r\n      payloadDataRecord.region.match(\/.*(Zone).*\/) != null\r\n    ) {\r\n      \/\/VolumeLimit\r\n      connectDataVolumeLimit.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.dischargeLocationCity,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Delivered',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'dischargeLocationCity',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.region,\r\n        },\r\n        {\r\n          fieldName: 'shipmentPeriodFrom',\r\n          operator: 'gte',\r\n          value: payloadDataRecord.deliveryStartDate,\r\n        },\r\n        {\r\n          fieldName: 'shipmentPeriodTo',\r\n          operator: 'lte',\r\n          value: payloadDataRecord.deliveryEndDate,\r\n        }\r\n      );\r\n    } else if (\r\n      payloadDataRecord.paymentTerm != 'DB' &&\r\n      payloadDataRecord.region.match(\/.*(Zone).*\/) == null\r\n    ) {\r\n      \/\/VolumeLimit\r\n      connectDataVolumeLimit.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.offersite,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Contract',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push({\r\n        fieldName: 'offersite',\r\n        operator: 'eq',\r\n        value: payloadDataRecord.site,\r\n      });\r\n    } else if (\r\n      payloadDataRecord.paymentTerm != 'DB' &&\r\n      payloadDataRecord.region.match(\/.*(Zone).*\/) != null\r\n    ) {\r\n      \/\/VolumeLimit\r\n      connectDataVolumeLimit.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.dischargeLocationCity,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Contract',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push({\r\n        fieldName: 'dischargeLocationCity',\r\n        operator: 'eq',\r\n        value: payloadDataRecord.region,\r\n      });\r\n    }\r\n  } else if (payloadDataRecord.object == volumeLimitObjId) {\r\n    \/\/ContractOffer\r\n    connectDataContractOffer.body = {\r\n      getLatestData: true,\r\n      sort: { requestDateUTC: 'asc' },\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'cropYear',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.season,\r\n          },\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.product,\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.quality,\r\n          },\r\n          {\r\n            fieldName: 'contractPrice',\r\n            operator: 'lte',\r\n            value: '',\r\n          },\r\n          {\r\n            fieldName: 'contractItemQuantity',\r\n            operator: 'lte',\r\n            value: '',\r\n          },\r\n          {\r\n            fieldName: 'requestIdUnique',\r\n            operator: 'nin',\r\n            value: [],\r\n          },\r\n          {\r\n            fieldName: 'requestType',\r\n            operator: 'eq',\r\n            value: 'Offer to sell',\r\n          },\r\n          {\r\n            fieldName: 'isRequestedByEkaCCSystem',\r\n            operator: 'eq',\r\n            value: true,\r\n          },\r\n          {\r\n            fieldName: 'approvalStatus',\r\n            operator: 'eq',\r\n            value: 'Awaiting review',\r\n          },\r\n          {\r\n            fieldName: 'isProcessing',\r\n            operator: 'ne',\r\n            value: true,\r\n          },\r\n        ],\r\n      },\r\n    };\r\n    \/\/Price\r\n    connectDataPrice.body = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'season',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.season,\r\n          },\r\n          {\r\n            fieldName: 'product',\r\n            operator: 'eq',\r\n            value: payloadDataRecord.product,\r\n          },\r\n          {\r\n            fieldName: 'quality',\r\n            operator: 'in',\r\n            value: ['All', payloadDataRecord.quality],\r\n          },\r\n          {\r\n            fieldName: 'startDateTime',\r\n            operator: 'lte',\r\n            value: currentDateTime,\r\n          },\r\n          {\r\n            fieldName: 'endDateTime',\r\n            operator: 'gte',\r\n            value: currentDateTime,\r\n          },\r\n          {\r\n            fieldName: 'status',\r\n            operator: 'ne',\r\n            value: 'Expired',\r\n          },\r\n          {\r\n            fieldName: 'isProcessing',\r\n            operator: 'ne',\r\n            value: true,\r\n          },\r\n        ],\r\n      },\r\n    };\r\n\r\n    \/\/VolumeLimit\r\n    connectDataVolumeLimit.body = {\r\n      filterData: {\r\n        filter: [\r\n          {\r\n            fieldName: 'isProcessing',\r\n            operator: 'ne',\r\n            value: true,\r\n          },\r\n        ],\r\n      },\r\n    };\r\n    volumeLimitUniqueFields.forEach((element) => {\r\n      connectDataVolumeLimit.body.filterData.filter.push({\r\n        fieldName: element,\r\n        operator: 'eq',\r\n        value: payloadDataRecord[element],\r\n      });\r\n    });\r\n    if (\r\n      payloadDataRecord.marketType == 'Delivered' &&\r\n      payloadDataRecord.region.match(\/.*(Zone).*\/) == null\r\n    ) {\r\n      \/\/Price\r\n      connectDataPrice.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.site,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Delivered',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push({\r\n        fieldName: 'offersite',\r\n        operator: 'eq',\r\n        value: payloadDataRecord.site,\r\n      });\r\n    } else if (\r\n      payloadDataRecord.marketType == 'Delivered' &&\r\n      payloadDataRecord.region.match(\/.*(Zone).*\/) != null\r\n    ) {\r\n      \/\/Price\r\n      connectDataPrice.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.region,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Delivered',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push({\r\n        fieldName: 'dischargeLocationCity',\r\n        operator: 'eq',\r\n        value: payloadDataRecord.region,\r\n      });\r\n    } else if (\r\n      payloadDataRecord.marketType == 'Contract' &&\r\n      payloadDataRecord.region.match(\/.*(Zone).*\/) == null\r\n    ) {\r\n      \/\/Price\r\n      connectDataPrice.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'ieqn',\r\n          value: payloadDataRecord.site,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Contract',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push({\r\n        fieldName: 'offersite',\r\n        operator: 'eq',\r\n        value: payloadDataRecord.site,\r\n      });\r\n    } else if (\r\n      payloadDataRecord.marketType == 'Contract' &&\r\n      payloadDataRecord.region.match(\/.*(Zone).*\/) != null\r\n    ) {\r\n      \/\/Price\r\n      connectDataPrice.body.filterData.filter.push(\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'eq',\r\n          value: payloadDataRecord.region,\r\n        },\r\n        {\r\n          fieldName: 'marketType',\r\n          operator: 'eq',\r\n          value: 'Contract',\r\n        }\r\n      );\r\n      \/\/Conract offer\r\n      connectDataContractOffer.body.filterData.filter.push({\r\n        fieldName: 'dischargeLocationCity',\r\n        operator: 'eq',\r\n        value: payloadDataRecord.region,\r\n      });\r\n    }\r\n    if (payloadDataRecord.quality == 'All' || payloadDataRecord.site == 'All') {\r\n      connectDataPrice.body.filterData.filter =\r\n        connectDataPrice.body.filterData.filter.filter(\r\n          (o) =>\r\n            !(o.fieldName == 'quality' && o.value == 'All') &&\r\n            !(o.fieldName == 'site' && o.value == 'All')\r\n        );\r\n    }\r\n  }\r\n}\r\n\r\nvar price_volumeLimit_DataSet = {};\r\nvar price_volumeLimit_DataSet_AllTested = true;\r\n\/\/This method will go through each price and volumeLimit in selected price and volumeLimit dataset\r\nfunction iterateOverSelectedPriceVolumeLimit() {\r\n  console.log('Running iterateOverSelectedPriceVolumeLimit');\r\n  \/\/ console.log('Before processing iterateOverSelectedPriceVolumeLimit:',price_volumeLimit_DataSet);\r\n  \/\/ price_volumeLimit_DataSet_AllTested = false\r\n  var priceVolumeLimitCombinationFound = false;\r\n  if (\r\n    price_volumeLimit_DataSet == undefined ||\r\n    price_volumeLimit_DataSet.price == undefined ||\r\n    price_volumeLimit_DataSet.volumeLimit == undefined ||\r\n    price_volumeLimit_DataSet.price.length == 0 ||\r\n    price_volumeLimit_DataSet.volumeLimit.length == 0 ||\r\n    (price_volumeLimit_DataSet.price.length <= 1 &&\r\n      price_volumeLimit_DataSet.volumeLimit.length <= 1)\r\n  ) {\r\n    price_volumeLimit_DataSet_AllTested = true;\r\n  } else {\r\n    for (let i = 0; i < price_volumeLimit_DataSet.price.length; i++) {\r\n      let breakPriceLoop = false;\r\n      for (let j = 0; j < price_volumeLimit_DataSet.volumeLimit.length; j++) {\r\n        if (\r\n          (price_volumeLimit_DataSet.price[i].isTestedAllVolumeLimit ||\r\n            price_volumeLimit_DataSet.volumeLimit[j].isTested) &&\r\n          price_volumeLimit_DataSet.volumeLimit.length == 1\r\n        ) {\r\n          price_volumeLimit_DataSet.volumeLimit[j].isTested = false;\r\n        } else if (\r\n          !(\r\n            price_volumeLimit_DataSet.price[i].isTestedAllVolumeLimit ||\r\n            price_volumeLimit_DataSet.volumeLimit[j].isTested\r\n          )\r\n        ) {\r\n          priceVolumeLimitCombinationFound = true;\r\n          \/\/ currentPriceRecord = price_volumeLimit_DataSet.price[i];\r\n          connectDataPrice.body = {\r\n            getLatestData: true,\r\n            filterData: {\r\n              filter: [\r\n                {\r\n                  fieldName: 'startDateTime',\r\n                  operator: 'lte',\r\n                  value: currentDateTime,\r\n                },\r\n                {\r\n                  fieldName: 'endDateTime',\r\n                  operator: 'gte',\r\n                  value: currentDateTime,\r\n                },\r\n                {\r\n                  fieldName: 'status',\r\n                  operator: 'ne',\r\n                  value: 'Expired',\r\n                },\r\n                {\r\n                  fieldName: 'isProcessing',\r\n                  operator: 'ne',\r\n                  value: true,\r\n                },\r\n              ],\r\n            },\r\n          };\r\n          priceUniqueFields.forEach((element) => {\r\n            connectDataPrice.body.filterData.filter.push({\r\n              fieldName: element,\r\n              operator: 'eq',\r\n              value: price_volumeLimit_DataSet.price[i][element],\r\n            });\r\n          });\r\n          connectDataPrice.body.filterData.filter.push({\r\n            fieldName: '_id',\r\n            operator: 'eq',\r\n            value: price_volumeLimit_DataSet.price[i]['_id'],\r\n          });\r\n          \/\/ currentVolumeLimitRecord = price_volumeLimit_DataSet.volumeLimit[j];\r\n          connectDataVolumeLimit.body = {\r\n            getLatestData: true,\r\n            filterData: {\r\n              filter: [\r\n                {\r\n                  fieldName: 'isProcessing',\r\n                  operator: 'ne',\r\n                  value: true,\r\n                },\r\n              ],\r\n            },\r\n          };\r\n          volumeLimitUniqueFields.forEach((element) => {\r\n            connectDataVolumeLimit.body.filterData.filter.push({\r\n              fieldName: element,\r\n              operator: 'eq',\r\n              value: price_volumeLimit_DataSet.volumeLimit[j][element],\r\n            });\r\n          });\r\n          connectDataVolumeLimit.body.filterData.filter.push({\r\n            fieldName: '_id',\r\n            operator: 'eq',\r\n            value: price_volumeLimit_DataSet.volumeLimit[j]['_id'],\r\n          });\r\n          price_volumeLimit_DataSet.price[i].isTested = true;\r\n          price_volumeLimit_DataSet.volumeLimit[j].isTested = true;\r\n          breakPriceLoop = true;\r\n          if (j == price_volumeLimit_DataSet.volumeLimit.length - 1) {\r\n            price_volumeLimit_DataSet.volumeLimit =\r\n              price_volumeLimit_DataSet.volumeLimit.map((o) => ({\r\n                ...o,\r\n                isTested: false,\r\n              }));\r\n            price_volumeLimit_DataSet.price[i].isTestedAllVolumeLimit = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n      if (breakPriceLoop) {\r\n        break;\r\n      }\r\n    }\r\n    if (priceVolumeLimitCombinationFound)\r\n      price_volumeLimit_DataSet_AllTested = false;\r\n    else price_volumeLimit_DataSet_AllTested = true;\r\n  }\r\n  \/\/ console.log('After processing iterateOverSelectedPriceVolumeLimit:',price_volumeLimit_DataSet);\r\n}\r\nasync function getGrowerProgram(contractOfferData, priceData) {\r\n  console.log('Running getGrowerProgram');\r\n  get_programName.body.output.get_programName = {\r\n    \/\/ dischargeLocationType: contractOfferData.dischargeLocationType,\r\n    dischargeLocationCountry:\r\n      'Australia' + '_' + contractOfferData.dischargeLocationCity,\r\n    product: contractOfferData.product,\r\n    bulkHandler: priceData.site, \/\/site from price\/volumeLimit\r\n\r\n    locationGroupType:\r\n      contractOfferData.offersite.match(\/.*(Zone).*\/) == null\r\n        ? 'Specific Location'\r\n        : 'Any location within a group',\r\n    \/\/ dischargeLocationCity: contractOfferData.dischargeLocationCity,\r\n\r\n    INCOTerm: contractOfferData.INCOTerm,\r\n    \/\/ profitCentre: priceData.profitCentre,\r\n    quality: contractOfferData.quality,\r\n    issustainable: contractOfferData.offersustainable ? 'Y' : 'N',\r\n    markettype: contractOfferData.markettype\r\n      ? contractOfferData.markettype\r\n      : 'CONTRACT',\r\n    \/\/ \"dischargeLocationState\": \"VICTORIA\",\r\n    corporate: corporate || contractOfferData.corporate,\r\n    cropYear: contractOfferData.cropYear,\r\n    contractPrice: contractOfferData.contractPrice,\r\n    isMultiGrade: contractOfferData.isMultiGrade\r\n      ? 'Y'\r\n      : contractOfferData.contractType.toLowerCase() == 'fixed grade'\r\n      ? 'N'\r\n      : 'Y',\r\n    paymentTerms: priceData.paymentTerm,\r\n    counterPartyName: contractOfferData.counterPartyName,\r\n    contractItemQuantity: contractOfferData.contractItemQuantity,\r\n  };\r\n  if (priceData.profitCenter)\r\n    get_programName.body.output.get_programName.profitCenter =\r\n      priceData.profitCenter;\r\n\r\n  var programDetail = await call_connectWorkflow(get_programName).catch(\r\n    (err) => {\r\n      console.log('Grower program not found :', err);\r\n      call_update_contractDomainData.body.output.update_contractDomainData = [\r\n        {\r\n          contractOfferData,\r\n          isProcessing: false,\r\n          offerExecutionTrackRecord:\r\n            contractOfferData.offerExecutionTrackRecord &&\r\n            contractOfferData.offerExecutionTrackRecord.length > 0\r\n              ? [\r\n                  ...contractOfferData.offerExecutionTrackRecord,\r\n                  JSON.stringify(err),\r\n                ]\r\n              : [JSON.stringify(err)],\r\n        },\r\n      ];\r\n      call_connectWorkflow(call_update_contractDomainData);\r\n      return false;\r\n    }\r\n  );\r\n  if (programDetail) return programDetail.data;\r\n  else return false;\r\n}\r\n\r\nasync function callCTRMInboundApi(\r\n  growerProgram,\r\n  contractOfferData,\r\n  volumeLimitData,\r\n  priceData\r\n) {\r\n  console.log('Running callCTRMInboundApi');\r\n  const contractHeader = {\r\n    CreatedBy: createdBy,\r\n    Operator: operator,\r\n    ContractType: contractType,\r\n    Corporate: corporate || contractOfferData.corporate,\r\n    \/\/ IsOriginationContract:\r\n    \/\/   reqContract.userType.toLowerCase() === 'grower'\r\n    \/\/     ? 'Y'\r\n    \/\/     : reqContract.userType.toLowerCase() === 'demand customer'\r\n    \/\/     ? 'N'\r\n    \/\/     : reqContract.userType.toLowerCase() === 'farmer'\r\n    \/\/     ? ' Y'\r\n    \/\/     : null,\r\n    IsOriginationContract: 'Y',\r\n    TemplateName: growerProgram.programName || '',\r\n    CPName: contractOfferData.counterPartyName || '',\r\n    CPRefNo: contractOfferData.BPRefNo || '',\r\n    PaymentTerm: priceData.paymentTerm || '',\r\n    ContractIssueDate: moment.utc().format('YYYY-MM-DDTHH:mm:ss'),\r\n    TraderName: traderName,\r\n    INCOTerm: contractOfferData.INCOTerm || '',\r\n    BrokerRefNo: contractOfferData.BrokerRefNo || '',\r\n  };\r\n\r\n  contractHeader.IsDraftContract =\r\n    contractHeader.IsOriginationContract === 'N' ? 'Y' : 'N';\r\n\r\n  if (contractHeader.IsDraftContract === 'Y') {\r\n    contractHeader.DraftCreatedOn = moment.utc().format('YYYY-MM-DDTHH:mm:ss');\r\n  }\r\n\r\n  const deliveryDetails = {\r\n    \/\/ DeliveryDetailCountry: contractOfferData.dischargeLocationCountry || '',\r\n    DeliveryDetailCity: contractOfferData.offersite || '',\r\n    DeliveryLocationGroupName: contractOfferData.dischargeLocationCity || '',\r\n  };\r\n\r\n  const itemQuantity = {\r\n    ItemQuantityValue: contractOfferData.contractItemQuantity || '',\r\n    ItemQuantityUnitId: weightUnit,\r\n  };\r\n\r\n  const shipmentPeriod = {\r\n    ShipmentFromDate: contractOfferData.shipmentPeriodFrom\r\n      ? moment(contractOfferData.shipmentPeriodFrom).format(\r\n          'YYYY-MM-DDT00:00:00'\r\n        )\r\n      : moment.utc().format('YYYY-MM-DDTHH:mm:ss'),\r\n    ShipmentToDate: contractOfferData.shipmentPeriodTo\r\n      ? moment(contractOfferData.shipmentPeriodTo).format('YYYY-MM-DDT23:59:59')\r\n      : moment.utc().format('YYYY-MM-DDTHH:mm:ss'),\r\n  };\r\n\r\n  const priceDetails = {\r\n    PayInCurrency: priceUnit,\r\n    PriceType: 'Fixed',\r\n    ContractPrice: {\r\n      ContractPriceValue: +contractOfferData.contractPrice,\r\n      ContractPriceUnitId: priceUnit + '\/' + weightUnit,\r\n    },\r\n  };\r\n\r\n  const itemDetails = {\r\n    ContractItemNo: '1',\r\n    Product: contractOfferData.product || '',\r\n    Cropyear: contractOfferData.cropYear || '',\r\n    Quality: contractOfferData.quality || '',\r\n    IsMultiGrade: contractOfferData.isMultiGrade\r\n      ? 'Y'\r\n      : contractOfferData.contractType.toLowerCase() == 'fixed grade'\r\n      ? 'N'\r\n      : 'Y',\r\n\r\n    \/\/ DeliveryTerm: reqContract.INCOTerm,\r\n    DeliveryDetails: deliveryDetails,\r\n    PriceDetails: priceDetails,\r\n    ItemQuantity: itemQuantity,\r\n    ShipmentPeriod: shipmentPeriod,\r\n  };\r\n\r\n  \/\/ if (reqContract.isMultiGrade == true) {\r\n  \/\/   itemDetails.MultiGradeDetails = JSON.parse(reqContract.multiGradeDifferentialDetails.replace(\/'\/g, '\"'))\r\n  \/\/     .multiGradeDifferentialDetail.filter(i => (i.multiGradeDifferential + '').toLowerCase() != 'base')\r\n  \/\/     .map(i => ({\r\n  \/\/       QualityName: i.qualityName || '',\r\n  \/\/       MultiGradeDiffDetails: {\r\n  \/\/         MultiGradeDiffValue: +i.multiGradeDifferential || 0,\r\n  \/\/         MultiGradeDiffPriceUnitId: i.multiGradeDifferentialUnit || ''\r\n  \/\/       }\r\n  \/\/     }));\r\n  \/\/ }\r\n\r\n  call_ctrmContractInboundAPI.body.output.EXTERNAL_CTRM_CONTRACT_INBOUND_API = {\r\n    App: 'CTRM',\r\n    Object: 'contractInbound_object',\r\n    RequestNumber: contractOfferData.requestId,\r\n    ObjectAction: 'CREATE',\r\n    ContractDetail: {\r\n      ContractHeader: contractHeader,\r\n      ItemDetails: [itemDetails],\r\n    },\r\n  };\r\n  await call_connectWorkflow(call_ctrmContractInboundAPI)\r\n    .then(async (contractDetails) => {\r\n      console.log('Contract Created successfully:', contractDetails);\r\n      contractDetails.data.Ext_RefNumber =\r\n        contractDetails.data['Ext.RefNumber'];\r\n      delete contractDetails.data['Ext.RefNumber'];\r\n      call_update_contractDomainData.body.output.update_contractDomainData = [\r\n        {\r\n          ...contractOfferData,\r\n          isProcessing: false,\r\n          contractRefNo: contractDetails.data.EntityRefNo,\r\n          approvalStatus: 'Approved',\r\n          bidid: priceData.priceId,\r\n          offerExecutionTrackRecord:\r\n            contractOfferData.offerExecutionTrackRecord &&\r\n            contractOfferData.offerExecutionTrackRecord.length > 0\r\n              ? [\r\n                  ...contractOfferData.offerExecutionTrackRecord,\r\n                  JSON.stringify(contractDetails),\r\n                ]\r\n              : [JSON.stringify(contractDetails)],\r\n        },\r\n      ];\r\n\r\n      await call_connectWorkflow(call_update_contractDomainData)\r\n        .then(async (result) => {\r\n          call_delete_contractDomainData.body.output.delete_contractDomainData =\r\n            [\r\n              contractOfferUniqueFields.reduce(\r\n                (result, item) => ({\r\n                  ...result,\r\n                  [item]: contractOfferData[item],\r\n                }),\r\n                {}\r\n              ),\r\n            ];\r\n          await call_connectWorkflow(call_delete_contractDomainData).catch(\r\n            (err) => {\r\n              console.log('Error during call_delete_contractDomainData:', err);\r\n            }\r\n          );\r\n          EXT_NOTIFICATION_OFFER_FOR_CONTRACT_APPROVED.body.output.EXT_NOTIFICATION_OFFER_FOR_CONTRACT_APPROVED =\r\n            call_update_contractDomainData.body.output.update_contractDomainData;\r\n          await call_connectWorkflow(\r\n            EXT_NOTIFICATION_OFFER_FOR_CONTRACT_APPROVED\r\n          ).catch((err) => {\r\n            console.log(\r\n              'Error during EXT_NOTIFICATION_OFFER_FOR_CONTRACT_APPROVED:',\r\n              err\r\n            );\r\n          });\r\n          elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal =\r\n            [];\r\n          let volumeLimitWithDailypurchased = volumeLimitUniqueFields.reduce(\r\n            (result, item) => ({\r\n              ...result,\r\n              [item]: volumeLimitData[item],\r\n            }),\r\n            {\r\n              dailypurchasedByContractOffer:\r\n                volumeLimitData.dailypurchasedByContractOffer\r\n                  ? volumeLimitData.dailypurchasedByContractOffer +\r\n                    contractOfferData.contractItemQuantity\r\n                  : contractOfferData.contractItemQuantity,\r\n              dailypurchased: volumeLimitData.dailypurchased,\r\n              dailyLimit: volumeLimitData.dailyLimit,\r\n            }\r\n          );\r\n\r\n          volumeLimitWithDailypurchased.dailypurchased =\r\n            volumeLimitWithDailypurchased.dailypurchased\r\n              ? volumeLimitWithDailypurchased.dailypurchased +\r\n                volumeLimitWithDailypurchased.dailypurchasedByContractOffer\r\n              : volumeLimitWithDailypurchased.dailypurchasedByContractOffer;\r\n          volumeLimitWithDailypurchased.limitBreachStatus =\r\n            volumeLimitWithDailypurchased.dailyLimit <\r\n            volumeLimitWithDailypurchased.dailypurchased\r\n              ? 'Y'\r\n              : 'N';\r\n          elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.push(\r\n            volumeLimitWithDailypurchased\r\n          );\r\n          await call_connectWorkflow(\r\n            elastic_updateVolumeLimitData_UpdateDailyPurchase_internal\r\n          ).catch((err) => {\r\n            console.log(\r\n              'Error during elastic_updateVolumeLimitData_UpdateDailyPurchase_internal:',\r\n              err\r\n            );\r\n          });\r\n          elastic_updatePriceData_UpdateDailyPurchase_internal.body.output.elastic_updatePriceData_UpdateDailyPurchase_internal =\r\n            [];\r\n          elastic_updatePriceData_UpdateDailyPurchase_internal.body.output.elastic_updatePriceData_UpdateDailyPurchase_internal.push(\r\n            priceUniqueFields.reduce(\r\n              (result, item) => ({\r\n                ...result,\r\n                [item]: priceData[item],\r\n              }),\r\n              {\r\n                status:\r\n                  volumeLimitWithDailypurchased.limitBreachStatus == 'Y'\r\n                    ? 'Expired'\r\n                    : 'Active',\r\n                purchased: volumeLimitWithDailypurchased.dailypurchased,\r\n              }\r\n            )\r\n          );\r\n\r\n          await call_connectWorkflow(\r\n            elastic_updatePriceData_UpdateDailyPurchase_internal\r\n          ).catch((err) => {\r\n            console.log(\r\n              'Error during elastic_updatePriceData_UpdateDailyPurchase_internal:',\r\n              err\r\n            );\r\n          });\r\n          \/\/ call_connectWorkflow(call_delete_contractDomainData).catch((err) => {\r\n          \/\/   console.log(\"Error during call_delete_contractDomainData:\", err);\r\n          \/\/ });\r\n          return true;\r\n        })\r\n        .catch((err) => {\r\n          console.log('Error during approving offer contract in Eka CC:', err);\r\n          return true;\r\n        });\r\n    })\r\n    .catch((err) => {\r\n      console.log('Error during contract creation in CTRM:', err);\r\n      call_update_contractDomainData.body.output.update_contractDomainData = [\r\n        {\r\n          contractOfferData,\r\n          isProcessing: false,\r\n          offerExecutionTrackRecord:\r\n            contractOfferData.offerExecutionTrackRecord &&\r\n            contractOfferData.offerExecutionTrackRecord.length > 0\r\n              ? [\r\n                  ...contractOfferData.offerExecutionTrackRecord,\r\n                  JSON.stringify(err),\r\n                ]\r\n              : [JSON.stringify(err)],\r\n        },\r\n      ];\r\n      call_connectWorkflow(call_update_contractDomainData);\r\n      return true;\r\n    });\r\n}\r\nfunction changeOfferTicketQualityAndSiteIfALL(\r\n  connectDataTicketOffer,\r\n  priceData\r\n) {\r\n  if (\r\n    connectDataTicketOffer.body.filterData.filter.filter(\r\n      (o) => o.fieldName == 'quality' && o.value == 'All'\r\n    ).length > 0\r\n  )\r\n    connectDataTicketOffer.body.filterData.filter.filter(\r\n      (o) => o.fieldName == 'quality' && o.value == 'All'\r\n    )[0].value = priceData.quality;\r\n\r\n  if (\r\n    connectDataTicketOffer.body.filterData.filter.filter(\r\n      (o) => o.fieldName == 'location' && o.value == 'All'\r\n    ).length > 0\r\n  )\r\n    connectDataTicketOffer.body.filterData.filter.filter(\r\n      (o) => o.fieldName == 'location' && o.value == 'All'\r\n    )[0].value = priceData.site;\r\n}\r\nfunction changeOfferContractQualityAndSiteIfALL(\r\n  connectDataContractOffer,\r\n  priceData\r\n) {\r\n  if (\r\n    connectDataContractOffer.body.filterData.filter.filter(\r\n      (o) => o.fieldName == 'quality' && o.value == 'All'\r\n    ).length > 0\r\n  )\r\n    connectDataContractOffer.body.filterData.filter.filter(\r\n      (o) => o.fieldName == 'quality' && o.value == 'All'\r\n    )[0].value = priceData.quality;\r\n\r\n  if (\r\n    connectDataContractOffer.body.filterData.filter.filter(\r\n      (o) => o.fieldName == 'offersite' && o.value == 'All'\r\n    ).length > 0\r\n  )\r\n    connectDataContractOffer.body.filterData.filter.filter(\r\n      (o) => o.fieldName == 'offersite' && o.value == 'All'\r\n    )[0].value = priceData.site;\r\n}\r\n\/\/ (async () => {\r\nif (payloadDataFiltered) {\r\n  \/\/Get unique list\r\n  \/\/ var payloadData = payloadDataFiltered.filter(\r\n  \/\/   ({ cropYear, product, quality, location, ticketHandlerCode }, index, a) =>\r\n  \/\/     a.findIndex(\r\n  \/\/       (e) =>\r\n  \/\/         cropYear === e.cropYear &&\r\n  \/\/         product === e.product &&\r\n  \/\/         quality === e.quality &&\r\n  \/\/         location === e.location &&\r\n  \/\/         ticketHandlerCode === e.ticketHandlerCode\r\n  \/\/     ) === index\r\n  \/\/ );\r\n  payloadData = payloadDataFiltered;\r\n  \/\/ console.log(payloadData);\r\n  var ticketOfferData;\r\n  var contractOfferData;\r\n  var priceData;\r\n  var volumeLimitData;\r\n  \/\/ var stopProcessing = false;\r\n  var offerTicket_contractTicket_price_volumeLimit_Over = false;\r\n  var is_price_volumeLimit_locked = false;\r\n  var ticketOfferUniqueFields;\r\n  var contractOfferUniqueFields;\r\n  var priceUniqueFields;\r\n  var volumeLimitUniqueFields;\r\n  var contractType;\r\n\r\n  Promise.all([\r\n    get_connectMeta(connectMetaTicketOffer),\r\n    get_connectMeta(connectMetaContractOffer),\r\n    get_connectMeta(connectMetaPrice),\r\n    get_connectMeta(connectMetaVolumeLimit),\r\n  ])\r\n    .then(async (ObjectMeta) => {\r\n      ticketOfferUniqueFields = JSON.parse(ObjectMeta[0]).uniqueFields;\r\n      contractOfferUniqueFields = JSON.parse(ObjectMeta[1]).uniqueFields;\r\n      priceUniqueFields = JSON.parse(ObjectMeta[2]).uniqueFields;\r\n      volumeLimitUniqueFields = JSON.parse(ObjectMeta[3]).uniqueFields;\r\n\r\n      for (let i = 0; i < payloadData.length; i++) {\r\n        currentDateTime = moment().format('YYYY-MM-DDTHH:mm:ss.SSS[Z]');\r\n        is_price_volumeLimit_locked = false;\r\n        let isFresh = true;\r\n        \/\/volumeLimit with marketType not in ['Contract','Delivered'] considered for ticket offers\r\n        \/\/price with marketType in ['Cash'] considered for ticket offers\r\n        if (\r\n          payloadData[i].object == ticketOfferObjId ||\r\n          (payloadData[i].object == volumeLimitObjId &&\r\n            payloadData[i].marketType != 'Contract' &&\r\n            payloadData[i].marketType != 'Delivered') ||\r\n          (payloadData[i].object == priceObjId &&\r\n            payloadData[i].marketType == 'Cash')\r\n        ) {\r\n          \/\/ \/\/This to get price and volumeLimit 'isProcessing' ne true before lockcing price and volumeLimit.\r\n          \/\/ connectDataPrice.body.filterData.filter[9].operator = \"ne\";\r\n          \/\/ connectDataVolumeLimit.body.filterData.filter[5].operator = \"ne\";\r\n          addFilterToFetchOfferTicketVolumeLimitPrice(payloadData[i]);\r\n          price_volumeLimit_DataSet_AllTested = false;\r\n          \/\/Repeat below process till all offers for same combination are executed\r\n\r\n          do {\r\n            offerTicket_contractTicket_price_volumeLimit_Over = false;\r\n            \/\/ (async () => {\r\n            \/\/ Fetch Price and VolumeLimit\r\n            await Promise.all([\r\n              get_connectData(connectDataPrice),\r\n              get_connectData(connectDataVolumeLimit),\r\n            ])\r\n              .then(async (connectData_price_volumeLimit) => {\r\n                if (\r\n                  connectData_price_volumeLimit[0].length > 0 &&\r\n                  connectData_price_volumeLimit[1].length > 0 &&\r\n                  connectData_price_volumeLimit[0][0].price &&\r\n                  connectData_price_volumeLimit[1][0].dailyLimit\r\n                ) {\r\n                  \/\/TicketOffer.price<=priceObj.price\r\n                  connectDataTicketOffer.body.filterData.filter[5].value =\r\n                    connectData_price_volumeLimit[0][0].price;\r\n                  \/\/TicketOffer.quantity<=volumeLimitObj.dailyLimit-volumeLimitObj.dailypurchased\r\n                  if (connectData_price_volumeLimit[1][0].dailypurchased) {\r\n                    connectDataTicketOffer.body.filterData.filter[6].value =\r\n                      connectData_price_volumeLimit[1][0].dailyLimit -\r\n                      connectData_price_volumeLimit[1][0].dailypurchased;\r\n                  } else\r\n                    connectDataTicketOffer.body.filterData.filter[6].value =\r\n                      connectData_price_volumeLimit[1][0].dailyLimit;\r\n\r\n                  priceData = connectData_price_volumeLimit[0][0];\r\n\r\n                  volumeLimitData = connectData_price_volumeLimit[1][0];\r\n\r\n                  \/\/Lock selected Price and volumeLimit\r\n                  if (!is_price_volumeLimit_locked) {\r\n                    connectDataPatchPrice.body.filterData.filter = [];\r\n                    priceUniqueFields.forEach((element) => {\r\n                      connectDataPatchPrice.body.filterData.filter.push({\r\n                        fieldName: element,\r\n                        operator: 'eq',\r\n                        value: priceData[element],\r\n                      });\r\n                    });\r\n                    connectDataPatchPrice.body.filterData.filter.push({\r\n                      fieldName: 'sys__data__state',\r\n                      operator: 'ne',\r\n                      value: 'Delete',\r\n                    });\r\n                    connectDataPatchPrice.body.filterData.filter.push({\r\n                      fieldName: 'isProcessing',\r\n                      operator: 'ne',\r\n                      value: true,\r\n                    });\r\n                    connectDataPatchPrice.body.payload = { isProcessing: true };\r\n\r\n                    \/\/Lock selected VolumeLimit\r\n                    connectDataPatchVolumeLimit.body.filterData.filter = [];\r\n                    volumeLimitUniqueFields.forEach((element) => {\r\n                      connectDataPatchVolumeLimit.body.filterData.filter.push({\r\n                        fieldName: element,\r\n                        operator: 'eq',\r\n                        value: volumeLimitData[element],\r\n                      });\r\n                    });\r\n                    connectDataPatchVolumeLimit.body.filterData.filter.push({\r\n                      fieldName: 'sys__data__state',\r\n                      operator: 'ne',\r\n                      value: 'Delete',\r\n                    });\r\n                    connectDataPatchVolumeLimit.body.filterData.filter.push({\r\n                      fieldName: 'isProcessing',\r\n                      operator: 'ne',\r\n                      value: true,\r\n                    });\r\n                    connectDataPatchVolumeLimit.body.payload = {\r\n                      isProcessing: true,\r\n                    };\r\n\r\n                    await Promise.all([\r\n                      get_connectData(connectDataPatchPrice),\r\n                      get_connectData(connectDataPatchVolumeLimit),\r\n                    ])\r\n                      .then(async function (\r\n                        connectDataPatch_price_volumeLimit\r\n                      ) {\r\n                        if (\r\n                          connectDataPatch_price_volumeLimit[0]\r\n                            .updatedRecordCount > 0 &&\r\n                          connectDataPatch_price_volumeLimit[1]\r\n                            .updatedRecordCount > 0\r\n                        ) {\r\n                          is_price_volumeLimit_locked = true;\r\n                          \/\/This to get price and volumeLimit 'isProcessing' eq true after lockcing price and volumeLimit.\r\n                          \/\/ connectDataPrice.body.filterData.filter[9].operator =\r\n                          \/\/   \"eq\";\r\n                          \/\/ connectDataVolumeLimit.body.filterData.filter[5].operator =\r\n                          \/\/   \"eq\";\r\n                          connectDataPrice.body.filterData.filter.filter(\r\n                            (o) => o.fieldName == 'isProcessing'\r\n                          )[0].operator = 'eq';\r\n                          connectDataVolumeLimit.body.filterData.filter.filter(\r\n                            (o) => o.fieldName == 'isProcessing'\r\n                          )[0].operator = 'eq';\r\n\r\n                          if (\r\n                            payloadData[i].object == volumeLimitObjId &&\r\n                            (payloadData[i].quality == 'All' ||\r\n                              payloadData[i].site == 'All')\r\n                          )\r\n                            changeOfferTicketQualityAndSiteIfALL(\r\n                              connectDataTicketOffer,\r\n                              priceData\r\n                            );\r\n                          \/\/Get a matching offer\r\n                          await get_connectData(connectDataTicketOffer)\r\n                            .then(async function (result) {\r\n                              if (result.length > 0) {\r\n                                ticketOfferData = result[0];\r\n                                \/\/ connectDataTicketOffer.body.filterData.filter[7].value.push(\r\n                                \/\/   ticketOfferData.ticketRefNo\r\n                                \/\/ );\r\n                                connectDataTicketOffer.body.filterData.filter\r\n                                  .filter(\r\n                                    (o) => o.fieldName == 'ticketRefNo'\r\n                                  )[0]\r\n                                  .value.push(ticketOfferData.ticketRefNo);\r\n                                connectDataPatchTicketOffer.body.filterData.filter =\r\n                                  [];\r\n                                \/\/Lock selected ticketOffer\r\n                                ticketOfferUniqueFields.forEach((element) => {\r\n                                  connectDataPatchTicketOffer.body.filterData.filter.push(\r\n                                    {\r\n                                      fieldName: element,\r\n                                      operator: 'eq',\r\n                                      value: ticketOfferData[element],\r\n                                    }\r\n                                  );\r\n                                });\r\n                                connectDataPatchTicketOffer.body.filterData.filter.push(\r\n                                  {\r\n                                    fieldName: 'sys__data__state',\r\n                                    operator: 'ne',\r\n                                    value: 'Delete',\r\n                                  }\r\n                                );\r\n                                connectDataPatchTicketOffer.body.filterData.filter.push(\r\n                                  {\r\n                                    fieldName: 'isProcessing',\r\n                                    operator: 'ne',\r\n                                    value: true,\r\n                                  }\r\n                                );\r\n                                connectDataPatchTicketOffer.body.payload = {\r\n                                  isProcessing: true,\r\n                                };\r\n\r\n                                \/\/Lock selected Ticket offer\r\n                                await Promise.all([\r\n                                  get_connectData(connectDataPatchTicketOffer),\r\n                                ]).then(async function (result) {\r\n                                  if (result[0].updatedRecordCount > 0) {\r\n                                    gcs_allocateTicket.body.output.EXTERNAL_GCS_ALLOCATE_TICKETS =\r\n                                      [];\r\n                                    gcs_allocateTicket.body.output.EXTERNAL_GCS_ALLOCATE_TICKETS.push(\r\n                                      {\r\n                                        ticketRefNo:\r\n                                          ticketOfferData.ticketRefNo,\r\n                                        cropYear: ticketOfferData.cropYear,\r\n                                        allocatedQuantity:\r\n                                          ticketOfferData.quantity,\r\n                                        ticketHandlerName:\r\n                                          ticketOfferData.ticketHandlerName,\r\n                                        ticketHandlerBpRefNo:\r\n                                          ticketOfferData.ticketHandlerBpRefNo,\r\n                                        ticketHandlerCode:\r\n                                          ticketOfferData.ticketHandlerCode,\r\n                                        contractId: '',\r\n                                        allocationDate: currentDateTime,\r\n                                        allocatedBy: ticketOfferData.requestBy,\r\n                                        pricingOption: priceData.pricingOption,\r\n                                        basePrice: ticketOfferData.offerPrice,\r\n                                        requestId: ticketOfferData.requestId,\r\n                                      }\r\n                                    );\r\n                                    \/\/Allocate ticket offer in GCS\r\n                                    await call_connectWorkflow(\r\n                                      gcs_allocateTicket\r\n                                    )\r\n                                      .then(async function (\r\n                                        response_gcs_allocateTicket\r\n                                      ) {\r\n                                        elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal =\r\n                                          [];\r\n                                        elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal.push(\r\n                                          ticketOfferUniqueFields.reduce(\r\n                                            (result, item) => ({\r\n                                              ...result,\r\n                                              [item]: ticketOfferData[item],\r\n                                            }),\r\n                                            {}\r\n                                          )\r\n                                        );\r\n                                        elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].isProcessing = false;\r\n                                        elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].offerExecutionTrackRecord =\r\n                                          ticketOfferData.offerExecutionTrackRecord &&\r\n                                          ticketOfferData\r\n                                            .offerExecutionTrackRecord.length >\r\n                                            0\r\n                                            ? [\r\n                                                ...ticketOfferData.offerExecutionTrackRecord,\r\n                                                response_gcs_allocateTicket.data\r\n                                                  .StatusMessage,\r\n                                              ]\r\n                                            : [\r\n                                                response_gcs_allocateTicket.data\r\n                                                  .StatusMessage,\r\n                                              ];\r\n\r\n                                        \/\/Set Offer status as 'Approved' if 200 status is received from GCS\r\n                                        if (\r\n                                          JSON.parse(\r\n                                            response_gcs_allocateTicket.data\r\n                                              .StatusMessage\r\n                                          )[0].Status == 200\r\n                                        ) {\r\n                                          elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].requestStatus =\r\n                                            'Approved';\r\n                                          elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].allocationDate =\r\n                                            moment().format('DD-MM-YYYY');\r\n                                          elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].bpRefNo =\r\n                                            ticketOfferData.bpRefNo;\r\n                                          EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD.body.output.EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD =\r\n                                            elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal;\r\n                                        }\r\n\r\n                                        await call_connectWorkflow(\r\n                                          elastic_updateTicketOfferData_withoutOfferExecution_internal\r\n                                        );\r\n                                        await call_connectWorkflow(\r\n                                          EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD\r\n                                        );\r\n                                      })\r\n                                      .catch((err) => {\r\n                                        console.log(\r\n                                          'Error during ticket allocation: ',\r\n                                          err\r\n                                        );\r\n                                        elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal =\r\n                                          [\r\n                                            {\r\n                                              ticketOfferData,\r\n                                              isProcessing: false,\r\n                                              offerExecutionTrackRecord:\r\n                                                contractOfferData.offerExecutionTrackRecord &&\r\n                                                contractOfferData\r\n                                                  .offerExecutionTrackRecord\r\n                                                  .length > 0\r\n                                                  ? [\r\n                                                      ...ticketOfferData.offerExecutionTrackRecord,\r\n                                                      JSON.stringify(err),\r\n                                                    ]\r\n                                                  : [JSON.stringify(err)],\r\n                                            },\r\n                                          ];\r\n                                        call_connectWorkflow(\r\n                                          elastic_updateTicketOfferData_withoutOfferExecution_internal\r\n                                        );\r\n                                      });\r\n                                  }\r\n                                  \/\/ else {\r\n                                  \/\/   offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                                  \/\/ }\r\n                                });\r\n                              } else {\r\n                                offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                              }\r\n                            })\r\n                            .catch((err) => {\r\n                              console.log(err);\r\n                              unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                                false,\r\n                                false,\r\n                                true,\r\n                                true\r\n                              );\r\n                              \/\/ res.status(500).send(err);\r\n                            });\r\n                        } else {\r\n                          offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                        }\r\n                      })\r\n                      .catch((err) => {\r\n                        console.log(err);\r\n                        unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                          false,\r\n                          false,\r\n                          true,\r\n                          true\r\n                        );\r\n                        res.status(500).send(err);\r\n                      });\r\n                  } else {\r\n                    if (\r\n                      payloadData[i].object == volumeLimitObjId &&\r\n                      (payloadData[i].quality == 'All' ||\r\n                        payloadData[i].site == 'All')\r\n                    )\r\n                      changeOfferTicketQualityAndSiteIfALL(\r\n                        connectDataTicketOffer,\r\n                        priceData\r\n                      );\r\n                    \/\/Get a matching offer\r\n                    await get_connectData(connectDataTicketOffer)\r\n                      .then(async function (result) {\r\n                        if (result.length > 0) {\r\n                          ticketOfferData = result[0];\r\n                          \/\/ connectDataTicketOffer.body.filterData.filter[7].value.push(\r\n                          \/\/   ticketOfferData.ticketRefNo\r\n                          \/\/ );\r\n                          connectDataTicketOffer.body.filterData.filter\r\n                            .filter((o) => o.fieldName == 'ticketRefNo')[0]\r\n                            .value.push(ticketOfferData.ticketRefNo);\r\n\r\n                          connectDataPatchTicketOffer.body.filterData.filter =\r\n                            [];\r\n                          \/\/Lock selected ticketOffer\r\n                          ticketOfferUniqueFields.forEach((element) => {\r\n                            connectDataPatchTicketOffer.body.filterData.filter.push(\r\n                              {\r\n                                fieldName: element,\r\n                                operator: 'eq',\r\n                                value: ticketOfferData[element],\r\n                              }\r\n                            );\r\n                          });\r\n                          connectDataPatchTicketOffer.body.filterData.filter.push(\r\n                            {\r\n                              fieldName: 'sys__data__state',\r\n                              operator: 'ne',\r\n                              value: 'Delete',\r\n                            }\r\n                          );\r\n                          connectDataPatchTicketOffer.body.filterData.filter.push(\r\n                            {\r\n                              fieldName: 'isProcessing',\r\n                              operator: 'ne',\r\n                              value: true,\r\n                            }\r\n                          );\r\n                          connectDataPatchTicketOffer.body.payload = {\r\n                            isProcessing: true,\r\n                          };\r\n\r\n                          \/\/Lock selected Ticket offer\r\n                          await Promise.all([\r\n                            get_connectData(connectDataPatchTicketOffer),\r\n                          ]).then(async function (result) {\r\n                            if (result[0].updatedRecordCount > 0) {\r\n                              gcs_allocateTicket.body.output.EXTERNAL_GCS_ALLOCATE_TICKETS =\r\n                                [];\r\n                              gcs_allocateTicket.body.output.EXTERNAL_GCS_ALLOCATE_TICKETS.push(\r\n                                {\r\n                                  ticketRefNo: ticketOfferData.ticketRefNo,\r\n                                  cropYear: ticketOfferData.cropYear,\r\n                                  allocatedQuantity: ticketOfferData.quantity,\r\n                                  ticketHandlerName:\r\n                                    ticketOfferData.ticketHandlerName,\r\n                                  ticketHandlerBpRefNo:\r\n                                    ticketOfferData.ticketHandlerBpRefNo,\r\n                                  ticketHandlerCode:\r\n                                    ticketOfferData.ticketHandlerCode,\r\n                                  contractId: '',\r\n                                  allocationDate: currentDateTime,\r\n                                  allocatedBy: ticketOfferData.requestBy,\r\n                                  pricingOption: priceData.pricingOption,\r\n                                  basePrice: ticketOfferData.offerPrice,\r\n                                  requestId: ticketOfferData.requestId,\r\n                                }\r\n                              );\r\n                              \/\/Allocate ticket offer in GCS\r\n                              await call_connectWorkflow(gcs_allocateTicket)\r\n                                .then(async function (\r\n                                  response_gcs_allocateTicket\r\n                                ) {\r\n                                  elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal =\r\n                                    [];\r\n                                  elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal.push(\r\n                                    ticketOfferUniqueFields.reduce(\r\n                                      (result, item) => ({\r\n                                        ...result,\r\n                                        [item]: ticketOfferData[item],\r\n                                      }),\r\n                                      {}\r\n                                    )\r\n                                  );\r\n                                  elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].isProcessing = false;\r\n                                  elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].offerExecutionTrackRecord =\r\n                                    ticketOfferData.offerExecutionTrackRecord &&\r\n                                    ticketOfferData.offerExecutionTrackRecord\r\n                                      .length > 0\r\n                                      ? [\r\n                                          ...ticketOfferData.offerExecutionTrackRecord,\r\n                                          response_gcs_allocateTicket.data\r\n                                            .StatusMessage,\r\n                                        ]\r\n                                      : [\r\n                                          response_gcs_allocateTicket.data\r\n                                            .StatusMessage,\r\n                                        ];\r\n                                  \/\/Set Offer status as 'Approved' if 200 status is received from GCS\r\n\r\n                                  if (\r\n                                    JSON.parse(\r\n                                      response_gcs_allocateTicket.data\r\n                                        .StatusMessage\r\n                                    )[0].Status == 200\r\n                                  ) {\r\n                                    elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].requestStatus =\r\n                                      'Approved';\r\n                                    elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].allocationDate =\r\n                                      moment().format('DD-MM-YYYY');\r\n                                    elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal[0].bpRefNo =\r\n                                      ticketOfferData.bpRefNo;\r\n                                    EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD.body.output.EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD =\r\n                                      elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal;\r\n                                  }\r\n\r\n                                  await call_connectWorkflow(\r\n                                    elastic_updateTicketOfferData_withoutOfferExecution_internal\r\n                                  );\r\n                                  await call_connectWorkflow(\r\n                                    EXT_NOTIFICATION_OFFER_WAREHOUSE_TICKET_SOLD\r\n                                  );\r\n                                })\r\n                                .catch((err) => {\r\n                                  console.log(\r\n                                    'Error during ticket allocation: ',\r\n                                    err\r\n                                  );\r\n                                  elastic_updateTicketOfferData_withoutOfferExecution_internal.body.output.elastic_updateTicketOfferData_withoutOfferExecution_internal =\r\n                                    [\r\n                                      {\r\n                                        ticketOfferData,\r\n                                        isProcessing: false,\r\n                                        offerExecutionTrackRecord:\r\n                                          contractOfferData.offerExecutionTrackRecord &&\r\n                                          contractOfferData\r\n                                            .offerExecutionTrackRecord.length >\r\n                                            0\r\n                                            ? [\r\n                                                ...ticketOfferData.offerExecutionTrackRecord,\r\n                                                JSON.stringify(err),\r\n                                              ]\r\n                                            : [JSON.stringify(err)],\r\n                                      },\r\n                                    ];\r\n                                  call_connectWorkflow(\r\n                                    elastic_updateTicketOfferData_withoutOfferExecution_internal\r\n                                  );\r\n                                });\r\n                            }\r\n                            \/\/ else {\r\n                            \/\/   offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                            \/\/ }\r\n                          });\r\n                        } else {\r\n                          offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                        }\r\n                      })\r\n                      .catch((err) => {\r\n                        console.log(err);\r\n                        unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                          false,\r\n                          false,\r\n                          true,\r\n                          true\r\n                        );\r\n                        res.status(500).send(err);\r\n                      });\r\n                  }\r\n\r\n                  if (isFresh) {\r\n                    isFresh = false;\r\n                    connectData_price_volumeLimit[0] =\r\n                      connectData_price_volumeLimit[0].map((o) => ({\r\n                        ...o,\r\n                        isTested: false,\r\n                        isTestedAllVolumeLimit: false,\r\n                      }));\r\n                    connectData_price_volumeLimit[0][0].isTested = true;\r\n                    if (connectData_price_volumeLimit[1].length == 1)\r\n                      connectData_price_volumeLimit[0][0].isTestedAllVolumeLimit = true;\r\n\r\n                    connectData_price_volumeLimit[1] =\r\n                      connectData_price_volumeLimit[1].map((o) => ({\r\n                        ...o,\r\n                        isTested: false,\r\n                      }));\r\n                    connectData_price_volumeLimit[1][0].isTested = true;\r\n                    price_volumeLimit_DataSet = {\r\n                      price: JSON.parse(\r\n                        JSON.stringify(connectData_price_volumeLimit[0])\r\n                      ),\r\n                      volumeLimit: JSON.parse(\r\n                        JSON.stringify(connectData_price_volumeLimit[1])\r\n                      ),\r\n                    };\r\n                    \/\/ price_volumeLimit_DataSet_AllTested = false;\r\n                  }\r\n                  \/\/This method will go through each price and volumeLimit in selected price and volumeLimit dataset\r\n                  if (offerTicket_contractTicket_price_volumeLimit_Over) {\r\n                    unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                      false,\r\n                      false,\r\n                      true,\r\n                      true\r\n                    );\r\n                    iterateOverSelectedPriceVolumeLimit();\r\n                  }\r\n                } else {\r\n                  offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                  price_volumeLimit_DataSet_AllTested = true;\r\n                }\r\n              })\r\n              .catch((err) => {\r\n                console.log(err);\r\n                res.status(500).send(err);\r\n              });\r\n            if (offerTicket_contractTicket_price_volumeLimit_Over)\r\n              unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                true,\r\n                false,\r\n                true,\r\n                true\r\n              );\r\n            \/\/ })();\r\n          } while (!price_volumeLimit_DataSet_AllTested);\r\n        }\r\n        \/\/volumeLimit with marketType in ['Contract','Delivered'] considered for contract offers\r\n        \/\/price with marketType in ['Contract','Delivered'] considered for contract offers\r\n        else if (\r\n          payloadData[i].object == contractOfferObjId ||\r\n          (payloadData[i].object == volumeLimitObjId &&\r\n            (payloadData[i].marketType == 'Contract' ||\r\n              payloadData[i].marketType == 'Delivered')) ||\r\n          (payloadData[i].object == priceObjId &&\r\n            (payloadData[i].marketType == 'Contract' ||\r\n              payloadData[i].marketType == 'Delivered'))\r\n        ) {\r\n          contractType =\r\n            req.body.propertyList['REQ_CONTRACTS_GROWER_CONTRACT_TYPE'];\r\n          addFilterToFetchOfferContractVolumeLimitPrice(payloadData[i]);\r\n          price_volumeLimit_DataSet_AllTested = false;\r\n\r\n          do {\r\n            \/\/ Fetch Price and VolumeLimit\r\n            await Promise.all([\r\n              get_connectData(connectDataPrice),\r\n              get_connectData(connectDataVolumeLimit),\r\n            ])\r\n              .then(async (connectData_price_volumeLimit) => {\r\n                if (\r\n                  connectData_price_volumeLimit[0].length > 0 &&\r\n                  connectData_price_volumeLimit[1].length > 0 &&\r\n                  connectData_price_volumeLimit[0][0].price &&\r\n                  connectData_price_volumeLimit[1][0].dailyLimit\r\n                ) {\r\n                  \/\/TicketOffer.price<=priceObj.price\r\n                  connectDataContractOffer.body.filterData.filter[3].value =\r\n                    connectData_price_volumeLimit[0][0].price;\r\n                  \/\/TicketOffer.quantity<=volumeLimitObj.dailyLimit-volumeLimitObj.dailypurchased\r\n                  if (connectData_price_volumeLimit[1][0].dailypurchased) {\r\n                    connectDataContractOffer.body.filterData.filter[4].value =\r\n                      connectData_price_volumeLimit[1][0].dailyLimit -\r\n                      connectData_price_volumeLimit[1][0].dailypurchased;\r\n                  } else\r\n                    connectDataContractOffer.body.filterData.filter[4].value =\r\n                      connectData_price_volumeLimit[1][0].dailyLimit;\r\n\r\n                  priceData = connectData_price_volumeLimit[0][0];\r\n\r\n                  volumeLimitData = connectData_price_volumeLimit[1][0];\r\n\r\n                  \/\/Lock selected Price and volumeLimit\r\n                  if (!is_price_volumeLimit_locked) {\r\n                    connectDataPatchPrice.body.filterData.filter = [];\r\n                    priceUniqueFields.forEach((element) => {\r\n                      connectDataPatchPrice.body.filterData.filter.push({\r\n                        fieldName: element,\r\n                        operator: 'eq',\r\n                        value: priceData[element],\r\n                      });\r\n                    });\r\n                    connectDataPatchPrice.body.filterData.filter.push({\r\n                      fieldName: 'sys__data__state',\r\n                      operator: 'ne',\r\n                      value: 'Delete',\r\n                    });\r\n                    connectDataPatchPrice.body.filterData.filter.push({\r\n                      fieldName: 'isProcessing',\r\n                      operator: 'ne',\r\n                      value: true,\r\n                    });\r\n                    connectDataPatchPrice.body.payload = { isProcessing: true };\r\n\r\n                    \/\/Lock selected VolumeLimit\r\n                    connectDataPatchVolumeLimit.body.filterData.filter = [];\r\n                    volumeLimitUniqueFields.forEach((element) => {\r\n                      connectDataPatchVolumeLimit.body.filterData.filter.push({\r\n                        fieldName: element,\r\n                        operator: 'eq',\r\n                        value: volumeLimitData[element],\r\n                      });\r\n                    });\r\n                    connectDataPatchVolumeLimit.body.filterData.filter.push({\r\n                      fieldName: 'sys__data__state',\r\n                      operator: 'ne',\r\n                      value: 'Delete',\r\n                    });\r\n                    connectDataPatchVolumeLimit.body.filterData.filter.push({\r\n                      fieldName: 'isProcessing',\r\n                      operator: 'ne',\r\n                      value: true,\r\n                    });\r\n                    connectDataPatchVolumeLimit.body.payload = {\r\n                      isProcessing: true,\r\n                    };\r\n\r\n                    await Promise.all([\r\n                      get_connectData(connectDataPatchPrice),\r\n                      get_connectData(connectDataPatchVolumeLimit),\r\n                    ])\r\n                      .then(async function (\r\n                        connectDataPatch_price_volumeLimit\r\n                      ) {\r\n                        if (\r\n                          connectDataPatch_price_volumeLimit[0]\r\n                            .updatedRecordCount > 0 &&\r\n                          connectDataPatch_price_volumeLimit[1]\r\n                            .updatedRecordCount > 0\r\n                        ) {\r\n                          is_price_volumeLimit_locked = true;\r\n                          connectDataPrice.body.filterData.filter.filter(\r\n                            (o) => o.fieldName == 'isProcessing'\r\n                          )[0].operator = 'eq';\r\n                          connectDataVolumeLimit.body.filterData.filter.filter(\r\n                            (o) => o.fieldName == 'isProcessing'\r\n                          )[0].operator = 'eq';\r\n\r\n                          if (\r\n                            payloadData[i].object == volumeLimitObjId &&\r\n                            (payloadData[i].quality == 'All' ||\r\n                              payloadData[i].site == 'All')\r\n                          )\r\n                            changeOfferContractQualityAndSiteIfALL(\r\n                              connectDataContractOffer,\r\n                              priceData\r\n                            );\r\n                          \/\/Get a matching contractOffer\r\n                          await get_connectData(connectDataContractOffer)\r\n                            .then(async function (result) {\r\n                              if (result.length > 0) {\r\n                                contractOfferData = result[0];\r\n                                connectDataContractOffer.body.filterData.filter\r\n                                  .filter(\r\n                                    (o) => o.fieldName == 'requestIdUnique'\r\n                                  )[0]\r\n                                  .value.push(\r\n                                    contractOfferData.requestIdUnique\r\n                                  );\r\n\r\n                                connectDataPatchContractOffer.body.filterData.filter =\r\n                                  [];\r\n                                \/\/set parameters to lock selected contractOffer\r\n                                contractOfferUniqueFields.forEach((element) => {\r\n                                  connectDataPatchContractOffer.body.filterData.filter.push(\r\n                                    {\r\n                                      fieldName: element,\r\n                                      operator: 'eq',\r\n                                      value: contractOfferData[element],\r\n                                    }\r\n                                  );\r\n                                });\r\n                                connectDataPatchContractOffer.body.filterData.filter.push(\r\n                                  {\r\n                                    fieldName: 'sys__data__state',\r\n                                    operator: 'ne',\r\n                                    value: 'Delete',\r\n                                  }\r\n                                );\r\n                                connectDataPatchContractOffer.body.filterData.filter.push(\r\n                                  {\r\n                                    fieldName: 'isProcessing',\r\n                                    operator: 'ne',\r\n                                    value: true,\r\n                                  }\r\n                                );\r\n                                connectDataPatchContractOffer.body.payload = {\r\n                                  isProcessing: true,\r\n                                };\r\n\r\n                                \/\/Lock selected contractOffer\r\n                                await Promise.all([\r\n                                  get_connectData(\r\n                                    connectDataPatchContractOffer\r\n                                  ),\r\n                                ]).then(async function (result) {\r\n                                  if (result[0].updatedRecordCount > 0) {\r\n                                    await getGrowerProgram(\r\n                                      contractOfferData,\r\n                                      priceData\r\n                                    ).then(async (growerProgram) => {\r\n                                      if (growerProgram) {\r\n                                        await callCTRMInboundApi(\r\n                                          growerProgram,\r\n                                          contractOfferData,\r\n                                          volumeLimitData,\r\n                                          priceData\r\n                                        );\r\n                                        console.log(\r\n                                          'Offer contract created successfully.'\r\n                                        );\r\n                                      }\r\n                                      \/\/ else {\r\n                                      \/\/   unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                                      \/\/     false,\r\n                                      \/\/     true,\r\n                                      \/\/     false,\r\n                                      \/\/     false\r\n                                      \/\/   );\r\n                                      \/\/ }\r\n                                    });\r\n                                  }\r\n                                });\r\n                              } else {\r\n                                offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                              }\r\n                            })\r\n                            .catch((err) => {\r\n                              console.log(err);\r\n                              unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                                false,\r\n                                false,\r\n                                true,\r\n                                true\r\n                              );\r\n                              res.status(500).send(err);\r\n                            });\r\n                        } else {\r\n                          offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                        }\r\n                      })\r\n                      .catch((err) => {\r\n                        console.log(err);\r\n                        unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                          false,\r\n                          false,\r\n                          true,\r\n                          true\r\n                        );\r\n                        res.status(500).send(err);\r\n                      });\r\n                  } else {\r\n                    if (\r\n                      payloadData[i].object == volumeLimitObjId &&\r\n                      (payloadData[i].quality == 'All' ||\r\n                        payloadData[i].site == 'All')\r\n                    )\r\n                      changeOfferContractQualityAndSiteIfALL(\r\n                        connectDataContractOffer,\r\n                        priceData\r\n                      );\r\n                    \/\/Get a matching contractOffer\r\n                    await get_connectData(connectDataContractOffer)\r\n                      .then(async function (result) {\r\n                        if (result.length > 0) {\r\n                          contractOfferData = result[0];\r\n                          connectDataContractOffer.body.filterData.filter\r\n                            .filter((o) => o.fieldName == 'requestIdUnique')[0]\r\n                            .value.push(contractOfferData.requestIdUnique);\r\n\r\n                          connectDataPatchContractOffer.body.filterData.filter =\r\n                            [];\r\n                          \/\/set parameters to lock selected contractOffer\r\n                          contractOfferUniqueFields.forEach((element) => {\r\n                            connectDataPatchContractOffer.body.filterData.filter.push(\r\n                              {\r\n                                fieldName: element,\r\n                                operator: 'eq',\r\n                                value: contractOfferData[element],\r\n                              }\r\n                            );\r\n                          });\r\n                          connectDataPatchContractOffer.body.filterData.filter.push(\r\n                            {\r\n                              fieldName: 'sys__data__state',\r\n                              operator: 'ne',\r\n                              value: 'Delete',\r\n                            }\r\n                          );\r\n                          connectDataPatchContractOffer.body.filterData.filter.push(\r\n                            {\r\n                              fieldName: 'isProcessing',\r\n                              operator: 'ne',\r\n                              value: true,\r\n                            }\r\n                          );\r\n                          connectDataPatchContractOffer.body.payload = {\r\n                            isProcessing: true,\r\n                          };\r\n\r\n                          \/\/Lock selected contractOffer\r\n                          await Promise.all([\r\n                            get_connectData(connectDataPatchContractOffer),\r\n                          ]).then(async function (result) {\r\n                            if (result[0].updatedRecordCount > 0) {\r\n                              await getGrowerProgram(\r\n                                contractOfferData,\r\n                                priceData\r\n                              ).then(async (growerProgram) => {\r\n                                if (growerProgram) {\r\n                                  await callCTRMInboundApi(\r\n                                    growerProgram,\r\n                                    contractOfferData,\r\n                                    volumeLimitData,\r\n                                    priceData\r\n                                  );\r\n                                  console.log(\r\n                                    'Offer contract created successfully.'\r\n                                  );\r\n                                }\r\n                                \/\/ else {\r\n                                \/\/   unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                                \/\/     false,\r\n                                \/\/     true,\r\n                                \/\/     false,\r\n                                \/\/     false\r\n                                \/\/   );\r\n                                \/\/ }\r\n                              });\r\n                            }\r\n                          });\r\n                        } else {\r\n                          offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                        }\r\n                      })\r\n                      .catch((err) => {\r\n                        console.log(err);\r\n                        unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                          false,\r\n                          false,\r\n                          true,\r\n                          true\r\n                        );\r\n                        res.status(500).send(err);\r\n                      });\r\n                  }\r\n\r\n                  if (isFresh) {\r\n                    isFresh = false;\r\n                    connectData_price_volumeLimit[0] =\r\n                      connectData_price_volumeLimit[0].map((o) => ({\r\n                        ...o,\r\n                        isTested: false,\r\n                        isTestedAllVolumeLimit: false,\r\n                      }));\r\n                    connectData_price_volumeLimit[0][0].isTested = true;\r\n                    if (connectData_price_volumeLimit[1].length == 1)\r\n                      connectData_price_volumeLimit[0][0].isTestedAllVolumeLimit = true;\r\n\r\n                    connectData_price_volumeLimit[1] =\r\n                      connectData_price_volumeLimit[1].map((o) => ({\r\n                        ...o,\r\n                        isTested: false,\r\n                      }));\r\n                    connectData_price_volumeLimit[1][0].isTested = true;\r\n\r\n                    price_volumeLimit_DataSet = {\r\n                      price: JSON.parse(\r\n                        JSON.stringify(connectData_price_volumeLimit[0])\r\n                      ),\r\n                      volumeLimit: JSON.parse(\r\n                        JSON.stringify(connectData_price_volumeLimit[1])\r\n                      ),\r\n                    };\r\n                    \/\/ price_volumeLimit_DataSet_AllTested = false;\r\n                  }\r\n                  \/\/This method will go through each price and volumeLimit in selected price and volumeLimit dataset\r\n                  if (offerTicket_contractTicket_price_volumeLimit_Over) {\r\n                    unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                      false,\r\n                      false,\r\n                      true,\r\n                      true\r\n                    );\r\n                    iterateOverSelectedPriceVolumeLimit();\r\n                  }\r\n                } else {\r\n                  offerTicket_contractTicket_price_volumeLimit_Over = true;\r\n                  price_volumeLimit_DataSet_AllTested = true;\r\n                }\r\n              })\r\n              .catch((err) => {\r\n                console.log(err);\r\n                res.status(500).send(err);\r\n              });\r\n            if (offerTicket_contractTicket_price_volumeLimit_Over)\r\n              unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n                false,\r\n                true,\r\n                true,\r\n                true\r\n              );\r\n            \/\/ })();\r\n          } while (!price_volumeLimit_DataSet_AllTested);\r\n        }\r\n\r\n        \/\/Unlock Price and VolumeLimit\r\n        unlock_ticketOffer_contractOffer_price_volumeLimit(\r\n          false,\r\n          false,\r\n          true,\r\n          true\r\n        );\r\n      }\r\n      res.status(200).send();\r\n    })\r\n    .catch((err) => {\r\n      console.log(err);\r\n      res.status(500).send(err);\r\n    });\r\n} else res.status(200).send();",
  "sys__UUID": "fd709667-b474-4e8a-bf9f-75bfe8716684",
  "type": "processor"
}
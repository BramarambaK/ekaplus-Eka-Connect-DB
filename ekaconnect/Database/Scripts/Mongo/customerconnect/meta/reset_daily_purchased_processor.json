{
  "_id": "reset_daily_purchased_processor",
  "name": "reset_daily_purchased_processor",
  "refType": "app",
  "refTypeId": "12325a98-a959-4939-9005-4158d136afcd",
  "snippet": "const appId = '12325a98-a959-4939-9005-4158d136afcd';\r\nconst regionSitesMasterDataObjId = 'ac4bf583-a9a4-446d-b6f9-3c083c3e1030';\r\nconst ticketObjId = 'a26737b3-a5a9-4fe9-b6f7-29218a3bc45a';\r\nconst tonnageLimitObjId = 'c98119db-1f7c-4802-b72a-6678f1ecc0f3';\r\nconst priceObjId = 'ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40';\r\nconst workflowTaskName =\r\n  'elastic_updateVolumeLimitData_UpdateDailyPurchase_internal';\r\n\r\nvar moment = require('moment');\r\nvar todaysDate = moment().utc().format('DD-MM-YYYY');\r\nvar currentDateTime = moment.utc();\r\nconsole.log('todaysDate:' + todaysDate);\r\n\r\nvar connectDataRegionSitesMasterData = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${regionSitesMasterDataObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\nvar connectMetaPrice = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n};\r\nvar connectMetaVolumeLimit = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${tonnageLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n};\r\n\r\nvar connectDataTickets = {\r\n  method: 'GET',\r\n  url: req.body.propertyList.eka_connect_host + `\/data\/${appId}\/${ticketObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'allocationDate',\r\n          operator: 'eq',\r\n          value: `${todaysDate}`,\r\n        },\r\n        {\r\n          fieldName: 'ticketStatus',\r\n          operator: 'eq',\r\n          value: 'Complete',\r\n        },\r\n        {\r\n          fieldName: 'ticketHandlerBpRefNo',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'cropYear',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'location',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'quantity',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'requestType',\r\n          operator: 'nin',\r\n          value: ['Offer for warehoused tickets'],\r\n        },\r\n        {\r\n          fieldName: 'ticketHandlerCode',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'isparentTicket',\r\n          operator: 'ne',\r\n          value: 'Y',\r\n        },\r\n        {\r\n          fieldName: 'pricingOption',\r\n          operator: 'ne',\r\n          value: 'Contract',\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectDataTonnageLimit = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${tonnageLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    pagination: {\r\n      start: 0,\r\n      limit: 1000,\r\n    },\r\n    sort: { sys__UUID: 'desc' },\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'bpRefNo',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'season',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'bpExternalCode',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectDataWorkflowCall = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    workflowTaskName: `${workflowTaskName}`,\r\n    task: `${workflowTaskName}`,\r\n    appId: `${appId}`,\r\n    output: {\r\n      elastic_updateVolumeLimitData_UpdateDailyPurchase_internal: [],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\nvar connectDataPrice = {\r\n  method: 'GET',\r\n  url: req.body.propertyList.eka_connect_host + `\/data\/${appId}\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    pagination: {\r\n      start: 0,\r\n      limit: 1000,\r\n    },\r\n    sort: { sys__UUID: 'desc' },\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'bpRefNo',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'season',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'status',\r\n          operator: 'ne',\r\n          value: 'Expired',\r\n        },\r\n        {\r\n          fieldName: 'startDateTime',\r\n          operator: 'lte',\r\n          value: `${moment().utc().format('YYYY-MM-DDTHH:mm:ss.SSS[Z]')}`,\r\n        },\r\n        {\r\n          fieldName: 'endDateTime',\r\n          operator: 'gte',\r\n          value: `${moment().utc().format('YYYY-MM-DDTHH:mm:ss.SSS[Z]')}`,\r\n        },\r\n        {\r\n          fieldName: 'bpExternalCode',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'pricingOption',\r\n          operator: 'ne',\r\n          value: 'Contract',\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nfunction get_connect(connectData) {\r\n  return new Promise(function (resolve, reject) {\r\n    \/\/ console.log(\"get_connect Request-\" + JSON.stringify(connectData));\r\n    request(connectData, function (err, response, body) {\r\n      \/\/ console.log(\"get_connect Response-\" + JSON.stringify(body));\r\n      if (response.statusCode === 200) resolve(body);\r\n      else {\r\n        reject(err || body);\r\n      }\r\n    });\r\n  });\r\n}\r\nfunction get_connectData_tickets() {\r\n  return new Promise(function (resolve, reject) {\r\n    \/\/ console.log('Ticket Request - ' + connectDataTickets.url);\r\n    \/\/ console.log('Ticket Body -' + JSON.stringify(connectDataTickets.body));\r\n    request(connectDataTickets, function (err, response, body) {\r\n      \/\/ console.log('Ticket Response - ' + JSON.stringify(body));\r\n      if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n        resolve(body); \/\/Success\r\n      } else {\r\n        reject(body); \/\/Failure\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction get_connectData_tonnageLimit() {\r\n  return new Promise(function (resolve, reject) {\r\n    \/\/ console.log('TonnageLimit Request - ' + connectDataTonnageLimit.url);\r\n    \/\/ console.log('TonnageLimit Body -' + JSON.stringify(connectDataTonnageLimit.body));\r\n    request(connectDataTonnageLimit, function (err, response, body) {\r\n      \/\/ console.log('TonnageLimit Response - ' + JSON.stringify(body));\r\n      if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n        resolve(body); \/\/Success\r\n      } else {\r\n        reject(body); \/\/Failure\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction get_connectData_WorkflowCall() {\r\n  return new Promise(function (resolve, reject) {\r\n    console.log('WorkflowCall Request - ' + connectDataWorkflowCall.url);\r\n    console.log(\r\n      'WorkflowCall Data -' + JSON.stringify(connectDataWorkflowCall.body)\r\n    );\r\n    request(connectDataWorkflowCall, function (err, response, body) {\r\n      \/\/   console.log('WorkflowCall Response - ' + JSON.stringify(body));\r\n      if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n        resolve(body); \/\/Success\r\n      } else {\r\n        reject(body); \/\/Failure\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction get_connectData_Price() {\r\n  return new Promise(function (resolve, reject) {\r\n    \/\/ console.log('get_connectData_Price Request - ' + connectDataPrice.url);\r\n    \/\/ console.log('get_connectData_Price Body -' + JSON.stringify(connectDataPrice.body));\r\n    request(connectDataPrice, function (err, response, body) {\r\n      \/\/ console.log('get_connectData_Price Response - ' + JSON.stringify(body));\r\n      if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n        resolve(body); \/\/Success\r\n      } else {\r\n        reject(body); \/\/Failure\r\n      }\r\n    });\r\n  });\r\n}\r\nvar connectDataWorkflowCallPrice = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    workflowTaskName: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    task: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    appId: `${appId}`,\r\n    output: {\r\n      elastic_updatePriceData_UpdateDailyPurchase_internal: [],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nfunction get_connectData_WorkflowCallPrice() {\r\n  return new Promise(function (resolve, reject) {\r\n    console.log(\r\n      'connectDataWorkflowCallPrice Request - ' +\r\n        connectDataWorkflowCallPrice.url\r\n    );\r\n    console.log(\r\n      'connectDataWorkflowCallPrice Data -' +\r\n        JSON.stringify(connectDataWorkflowCallPrice.body)\r\n    );\r\n    request(connectDataWorkflowCallPrice, function (err, response, body) {\r\n      \/\/ console.log('connectDataWorkflowCallPrice Response - ' + JSON.stringify(body));\r\n      if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n        resolve(body); \/\/Success\r\n      } else {\r\n        reject(body); \/\/Failure\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction getSumQuantityByGroupKey(array, groups, valueKey) {\r\n  var map = new Map();\r\n  groups = [].concat(groups);\r\n  return array.reduce((r, o) => {\r\n    groups.reduce((m, k, i, { length }) => {\r\n      var child;\r\n      if (m.has(o[k])) return m.get(o[k]);\r\n      if (i + 1 === length) {\r\n        child = Object.assign(\r\n          ...groups.map((k) => ({\r\n            [k]: o[k],\r\n          })),\r\n          {\r\n            [valueKey]: 0,\r\n          }\r\n        );\r\n        r.push(child);\r\n      } else {\r\n        child = new Map();\r\n      }\r\n      m.set(o[k], child);\r\n      return child;\r\n    }, map)[valueKey] += +o[valueKey];\r\n    return r;\r\n  }, []);\r\n}\r\n\r\nget_connectData_tickets()\r\n  .then(async (ticketsData) => {\r\n    connectDataRegionSitesMasterData.body.filterData.filter[0].value =\r\n      ticketsData.map((entry) => entry.location).filter((entry) => entry);\r\n    var RegionSitesMasterData = await get_connect(\r\n      connectDataRegionSitesMasterData\r\n    );\r\n    ticketsData = ticketsData\r\n      .map((ticketEntry) => {\r\n        const container = RegionSitesMasterData.find(\r\n          (regionSitesEntry) =>\r\n            regionSitesEntry.site.toLowerCase() ==\r\n            ticketEntry.location.toLowerCase()\r\n        );\r\n        if (container) ticketEntry.region = container.region;\r\n        return ticketEntry;\r\n      })\r\n      .filter((ticketEntry) => ticketEntry.region);\r\n\r\n    var priceUniqueFields = JSON.parse(\r\n      await get_connect(connectMetaPrice)\r\n    ).uniqueFields;\r\n    priceUniqueFields.push('purchased');\r\n    priceUniqueFields.push('previousDayPurchased');\r\n    priceUniqueFields.push('clientTimezoneOffset');\r\n    priceUniqueFields.push('id');\r\n\r\n    var volumeLimitUniqueFields = JSON.parse(\r\n      await get_connect(connectMetaVolumeLimit)\r\n    ).uniqueFields;\r\n    volumeLimitUniqueFields.push('id');\r\n    volumeLimitUniqueFields.push('dailypurchased');\r\n    volumeLimitUniqueFields.push('limitBreachStatus');\r\n\r\n    \/\/Converting all important ticket fields to lower case to handle case insensitive\r\n    ticketsData.forEach(function (item) {\r\n      if (item.ticketHandlerCode)\r\n        item.ticketHandlerCode = item.ticketHandlerCode.toLowerCase();\r\n      if (item.product) item.product = item.product.toLowerCase();\r\n      if (item.region) item.region = item.region.toLowerCase();\r\n      if (item.quality) item.quality = item.quality.toLowerCase();\r\n      if (item.location) item.location = item.location.toLowerCase();\r\n      if (item.pricingOption)\r\n        item.pricingOption = item.pricingOption.toLowerCase();\r\n    });\r\n    ticketsData = ticketsData.filter((e) => e.pricingOption != 'contract');\r\n    console.log('***********************************');\r\n    var sumQuantityTicket = getSumQuantityByGroupKey(\r\n      ticketsData,\r\n      [\r\n        'ticketHandlerBpRefNo',\r\n        'ticketHandlerCode',\r\n        'cropYear',\r\n        'product',\r\n        'region',\r\n        'quality',\r\n        'location',\r\n        'pricingOption',\r\n      ],\r\n      'quantity'\r\n    );\r\n    \/\/ console.log('***********************************');\r\n    \/\/ console.log('sumQuantityTicket:' + JSON.stringify(sumQuantityTicket));\r\n    \/\/ console.log('***********************************');\r\n\r\n    \/\/Get sum of quantity by grouping on ['ticketHandlerBpRefNo','ticketHandlerCode','cropYear','product','region','quality'] and add to sumQuantityTicket with 'location'='all'\r\n    const sumQuantityTicketAllLocation = getSumQuantityByGroupKey(\r\n      ticketsData,\r\n      [\r\n        'ticketHandlerBpRefNo',\r\n        'ticketHandlerCode',\r\n        'cropYear',\r\n        'product',\r\n        'region',\r\n        'quality',\r\n        'pricingOption',\r\n      ],\r\n      'quantity'\r\n    );\r\n    sumQuantityTicketAllLocation.forEach((sumQuantityAllLocation) => {\r\n      sumQuantityTicket.push({\r\n        ticketHandlerBpRefNo: sumQuantityAllLocation['ticketHandlerBpRefNo'],\r\n        ticketHandlerCode: sumQuantityAllLocation['ticketHandlerCode'],\r\n        cropYear: sumQuantityAllLocation['cropYear'],\r\n        product: sumQuantityAllLocation['product'],\r\n        region: sumQuantityAllLocation['region'],\r\n        pricingOption: sumQuantityAllLocation['pricingOption'],\r\n        quality: sumQuantityAllLocation['quality'],\r\n        location: 'all',\r\n        quantity: sumQuantityAllLocation['quantity'],\r\n      });\r\n    });\r\n    \/\/ console.log('***********************************');\r\n    \/\/ console.log(\r\n    \/\/   'sumQuantityTicketAllLocation:' + JSON.stringify(sumQuantityTicket)\r\n    \/\/ );\r\n    \/\/ console.log('***********************************');\r\n\r\n    \/\/Get sum of quantity by grouping on ['ticketHandlerBpRefNo','ticketHandlerCode','cropYear','product','region','location'] and add to sumQuantityTicket with 'quality'='all'\r\n    const sumQuantityTicketAllQuality = getSumQuantityByGroupKey(\r\n      ticketsData,\r\n      [\r\n        'ticketHandlerBpRefNo',\r\n        'ticketHandlerCode',\r\n        'cropYear',\r\n        'product',\r\n        'region',\r\n        'location',\r\n        'pricingOption',\r\n      ],\r\n      'quantity'\r\n    );\r\n    sumQuantityTicketAllQuality.forEach((sumQuantityAllQuality) => {\r\n      sumQuantityTicket.push({\r\n        ticketHandlerBpRefNo: sumQuantityAllQuality['ticketHandlerBpRefNo'],\r\n        ticketHandlerCode: sumQuantityAllQuality['ticketHandlerCode'],\r\n        cropYear: sumQuantityAllQuality['cropYear'],\r\n        product: sumQuantityAllQuality['product'],\r\n        region: sumQuantityAllQuality['region'],\r\n        pricingOption: sumQuantityAllQuality['pricingOption'],\r\n        quality: 'all',\r\n        location: sumQuantityAllQuality['location'],\r\n        quantity: sumQuantityAllQuality['quantity'],\r\n      });\r\n    });\r\n    \/\/ console.log('***********************************');\r\n    \/\/ console.log(\r\n    \/\/   'sumQuantityTicketAllQuality:' + JSON.stringify(sumQuantityTicket)\r\n    \/\/ );\r\n    \/\/ console.log('***********************************');\r\n\r\n    \/\/Get sum of quantity by grouping on ['ticketHandlerBpRefNo','ticketHandlerCode','cropYear','product','region'] and add to sumQuantityTicket with 'quality'='all' , 'location'='all'\r\n    const sumQuantityTicketAllQualityLocation = getSumQuantityByGroupKey(\r\n      ticketsData,\r\n      [\r\n        'ticketHandlerBpRefNo',\r\n        'ticketHandlerCode',\r\n        'cropYear',\r\n        'product',\r\n        'region',\r\n        'pricingOption',\r\n      ],\r\n      'quantity'\r\n    );\r\n    sumQuantityTicketAllQualityLocation.forEach(\r\n      (sumQuantityAllQualityLocation) => {\r\n        sumQuantityTicket.push({\r\n          ticketHandlerBpRefNo:\r\n            sumQuantityAllQualityLocation['ticketHandlerBpRefNo'],\r\n          ticketHandlerCode: sumQuantityAllQualityLocation['ticketHandlerCode'],\r\n          cropYear: sumQuantityAllQualityLocation['cropYear'],\r\n          product: sumQuantityAllQualityLocation['product'],\r\n          region: sumQuantityAllQualityLocation['region'],\r\n          pricingOption: sumQuantityAllQualityLocation['pricingOption'],\r\n          quality: 'all',\r\n          location: 'all',\r\n          quantity: sumQuantityAllQualityLocation['quantity'],\r\n        });\r\n      }\r\n    );\r\n    console.log('***********************************');\r\n    console.log(\r\n      'sumQuantityTicketAllQualityLocation:' + JSON.stringify(sumQuantityTicket)\r\n    );\r\n    console.log('***********************************');\r\n\r\n    var isDataEmpty = false;\r\n    var sumTicket;\r\n    var limitBreachedVolumeLimitdata = [];\r\n    do {\r\n      \/\/ var tonnageLimitData = await get_connectData_tonnageLimit();\r\n      await get_connectData_tonnageLimit().then(async (tonnageLimitData) => {\r\n        \/\/ console.log('tonnageLimitData:' + tonnageLimitData);\r\n        \/\/ console.log('tonnageLimitData.length:' + tonnageLimitData.length);\r\n        if (tonnageLimitData.length !== 0) {\r\n          for (let i = 0; i < tonnageLimitData.length; i++) {\r\n            sumTicket = sumQuantityTicket.filter(\r\n              (sumTicket) =>\r\n                sumTicket['ticketHandlerBpRefNo'] ===\r\n                  tonnageLimitData[i]['bpRefNo'] &&\r\n                sumTicket['ticketHandlerCode'] ===\r\n                  tonnageLimitData[i]['bpExternalCode'].toLowerCase() &&\r\n                sumTicket['cropYear'] === tonnageLimitData[i]['season'] &&\r\n                sumTicket['product'] ===\r\n                  tonnageLimitData[i]['product'].toLowerCase() &&\r\n                sumTicket['region'] ===\r\n                  tonnageLimitData[i]['region'].toLowerCase() &&\r\n                sumTicket['quality'] ===\r\n                  tonnageLimitData[i]['quality'].toLowerCase() &&\r\n                sumTicket['location'] ===\r\n                  tonnageLimitData[i]['site'].toLowerCase()\r\n            );\r\n            if (sumTicket.length > 0) {\r\n              sumTicket.forEach((e) => {\r\n                e.quantity =\r\n                  e.quantity +\r\n                  (tonnageLimitData[i]['dailypurchasedByContractOffer']\r\n                    ? tonnageLimitData[i]['dailypurchasedByContractOffer']\r\n                    : 0);\r\n              });\r\n              tonnageLimitData[i]['dailypurchased'] = sumTicket.reduce(\r\n                (n, { quantity }) => n + quantity,\r\n                0\r\n              );\r\n              if (\r\n                tonnageLimitData[i]['dailypurchased'] >\r\n                tonnageLimitData[i]['dailyLimit']\r\n              ) {\r\n                tonnageLimitData[i]['limitBreachStatus'] = 'Y';\r\n                sumTicket.forEach((e) => {\r\n                  e.limitBreachStatus = 'Y';\r\n                });\r\n              } else {\r\n                tonnageLimitData[i]['limitBreachStatus'] = 'N';\r\n              }\r\n            } else {\r\n              tonnageLimitData[i]['dailypurchased'] = 0;\r\n              tonnageLimitData[i]['dailypurchasedByContractOffer'] = 0;\r\n              tonnageLimitData[i]['limitBreachStatus'] = 'N';\r\n            }\r\n\r\n            tonnageLimitData[i]['id'] = tonnageLimitData[i]['_id'];\r\n\r\n            connectDataWorkflowCall['body']['output'][\r\n              'elastic_updateVolumeLimitData_UpdateDailyPurchase_internal'\r\n            ].push(tonnageLimitData[i]);\r\n          }\r\n          limitBreachedVolumeLimitdata.push(\r\n            ...connectDataWorkflowCall.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.filter(\r\n              (o) =>\r\n                o.limitBreachStatus == 'Y' &&\r\n                (o.site == 'All' || o.quality == 'All')\r\n            )\r\n          );\r\n          limitBreachedVolumeLimitdata.forEach((o) => {\r\n            if (o.site == 'All' && o.quality == 'All')\r\n              connectDataWorkflowCall.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal\r\n                .filter(\r\n                  (entry) =>\r\n                    o.bpRefNo === entry.bpRefNo &&\r\n                    o.bpExternalCode.toLowerCase() ===\r\n                      entry.bpExternalCode.toLowerCase() &&\r\n                    o.season === entry.season &&\r\n                    o.product.toLowerCase() === entry.product.toLowerCase() &&\r\n                    o.region.toLowerCase() === entry.region.toLowerCase() &&\r\n                    entry.limitBreachStatus != 'Y'\r\n                )\r\n                .forEach((entry) => (entry.limitBreachStatus = 'Y'));\r\n            else if (o.site == 'All')\r\n              connectDataWorkflowCall.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal\r\n                .filter(\r\n                  (entry) =>\r\n                    o.bpRefNo === entry.bpRefNo &&\r\n                    o.bpExternalCode.toLowerCase() ===\r\n                      entry.bpExternalCode.toLowerCase() &&\r\n                    o.season === entry.season &&\r\n                    o.product.toLowerCase() === entry.product.toLowerCase() &&\r\n                    o.region.toLowerCase() === entry.region.toLowerCase() &&\r\n                    o.quality.toLowerCase() === entry.quality.toLowerCase() &&\r\n                    entry.limitBreachStatus != 'Y'\r\n                )\r\n                .forEach((entry) => (entry.limitBreachStatus = 'Y'));\r\n            else if (o.quality == 'All')\r\n              connectDataWorkflowCall.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal\r\n                .filter(\r\n                  (entry) =>\r\n                    o.bpRefNo === entry.bpRefNo &&\r\n                    o.bpExternalCode.toLowerCase() ===\r\n                      entry.bpExternalCode.toLowerCase() &&\r\n                    o.season === entry.season &&\r\n                    o.product.toLowerCase() === entry.product.toLowerCase() &&\r\n                    o.region.toLowerCase() === entry.region.toLowerCase() &&\r\n                    o.site.toLowerCase() === entry.site.toLowerCase() &&\r\n                    entry.limitBreachStatus != 'Y'\r\n                )\r\n                .forEach((entry) => (entry.limitBreachStatus = 'Y'));\r\n          });\r\n\r\n          await get_connectData_WorkflowCall().catch((err) => {\r\n            console.log(err);\r\n            res.status(500).send(err);\r\n          });\r\n\r\n          connectDataWorkflowCall['body']['output'][\r\n            'elastic_updateVolumeLimitData_UpdateDailyPurchase_internal'\r\n          ] = [];\r\n          connectDataTonnageLimit['body']['pagination']['start'] =\r\n            connectDataTonnageLimit['body']['pagination']['start'] +\r\n            connectDataTonnageLimit['body']['pagination']['limit'];\r\n        } else {\r\n          isDataEmpty = true;\r\n        }\r\n      });\r\n    } while (!isDataEmpty);\r\n\r\n    \/\/Updating purchased column in price\r\n    isDataEmpty = false;\r\n    var isUpdated = false;\r\n    var sumTicketFilterPricingOption;\r\n    do {\r\n      \/\/ var priceData = await get_connectData_Price();\r\n      await get_connectData_Price().then(async (priceData) => {\r\n        \/\/ console.log('priceData:' + priceData);\r\n        \/\/ console.log('priceData.length:' + priceData.length);\r\n        var offset;\r\n        var currentDateTimeWithTimezone;\r\n        if (priceData.length !== 0) {\r\n          for (let i = 0; i < priceData.length; i++) {\r\n            priceData[i]['previousDayPurchased'] =\r\n              typeof priceData[i]['purchased'] === 'undefined' ||\r\n              priceData[i]['purchased'] == null ||\r\n              priceData[i]['purchased'] == ''\r\n                ? 0\r\n                : priceData[i]['purchased'];\r\n\r\n            sumTicket = sumQuantityTicket.filter(\r\n              (sumTicket) =>\r\n                sumTicket['ticketHandlerBpRefNo'] === priceData[i]['bpRefNo'] &&\r\n                sumTicket['ticketHandlerCode'] ===\r\n                  priceData[i]['bpExternalCode'].toLowerCase() &&\r\n                sumTicket['cropYear'] === priceData[i]['season'] &&\r\n                sumTicket['product'] ===\r\n                  priceData[i]['product'].toLowerCase() &&\r\n                sumTicket['region'] === priceData[i]['region'].toLowerCase() &&\r\n                sumTicket['quality'] ===\r\n                  priceData[i]['quality'].toLowerCase() &&\r\n                sumTicket['location'] === priceData[i]['site'].toLowerCase()\r\n            );\r\n\r\n            if (sumTicket.length > 0) {\r\n              sumTicketFilterPricingOption = sumTicket.find(\r\n                (entry) =>\r\n                  (entry['pricingOption'] === 'cash sustainable' &&\r\n                    priceData[i]['pricingOption'].toLowerCase() === 'cash' &&\r\n                    priceData[i]['sustainable']) ||\r\n                  (entry['pricingOption'] === 'cash' &&\r\n                    priceData[i]['pricingOption'].toLowerCase() === 'cash' &&\r\n                    !priceData[i]['sustainable']) ||\r\n                  (!['cash sustainable', 'cash'].includes(\r\n                    entry['pricingOption']\r\n                  ) &&\r\n                    entry['pricingOption'] ===\r\n                      priceData[i]['pricingOption'].toLowerCase())\r\n              );\r\n\r\n              isUpdated = true;\r\n              priceData[i]['id'] = priceData[i]['_id'];\r\n              \/\/ priceData[i] = priceUniqueFields.reduce(\r\n              \/\/   (result, item) => ({ ...result, [item]: priceData[i][item] }),\r\n              \/\/   {}\r\n              \/\/ );\r\n              if (sumTicketFilterPricingOption) {\r\n                priceData[i]['purchased'] =\r\n                  (typeof priceData[i]['previousDayPurchased'] ===\r\n                    'undefined' ||\r\n                  priceData[i]['previousDayPurchased'] == null ||\r\n                  priceData[i]['previousDayPurchased'] == ''\r\n                    ? 0\r\n                    : priceData[i]['previousDayPurchased']) +\r\n                  sumTicketFilterPricingOption['quantity'];\r\n              }\r\n              if (sumTicket[0].limitBreachStatus == 'Y') {\r\n                priceData[i].status = 'Expired';\r\n                offset = priceData[i].clientTimezoneOffset\r\n                  ? priceData[i].clientTimezoneOffset\r\n                  : 0;\r\n                currentDateTimeWithTimezone = currentDateTime\r\n                  .clone()\r\n                  .subtract(offset, 'minutes');\r\n                priceData[i].endDate =\r\n                  currentDateTimeWithTimezone.format('YYYY-MM-DD');\r\n                priceData[i].endTime =\r\n                  currentDateTimeWithTimezone.format('HH:mm');\r\n                priceData[i].endDateTime = moment()\r\n                  .utc()\r\n                  .format('YYYY-MM-DDTHH:mm:ss[Z]');\r\n              }\r\n            }\r\n            sumTicket = sumQuantityTicket.find(\r\n              (sumTicket) =>\r\n                sumTicket.limitBreachStatus == 'Y' &&\r\n                sumTicket['ticketHandlerBpRefNo'] === priceData[i]['bpRefNo'] &&\r\n                sumTicket['ticketHandlerCode'] ===\r\n                  priceData[i]['bpExternalCode'].toLowerCase() &&\r\n                sumTicket['cropYear'] === priceData[i]['season'] &&\r\n                sumTicket['product'] ===\r\n                  priceData[i]['product'].toLowerCase() &&\r\n                sumTicket['region'] === priceData[i]['region'].toLowerCase() &&\r\n                (sumTicket['quality'] === 'all' ||\r\n                  sumTicket['quality'] ===\r\n                    priceData[i]['quality'].toLowerCase()) &&\r\n                (sumTicket['location'] === 'all' ||\r\n                  sumTicket['location'] === priceData[i]['site'].toLowerCase())\r\n            );\r\n            if (sumTicket) {\r\n              isUpdated = true;\r\n              priceData[i]['id'] = priceData[i]['_id'];\r\n              priceData[i] = priceUniqueFields.reduce(\r\n                (result, item) => ({ ...result, [item]: priceData[i][item] }),\r\n                {}\r\n              );\r\n              priceData[i].status = 'Expired';\r\n              offset = priceData[i].clientTimezoneOffset\r\n                ? priceData[i].clientTimezoneOffset\r\n                : 0;\r\n              currentDateTimeWithTimezone = currentDateTime\r\n                .clone()\r\n                .subtract(offset, 'minutes');\r\n              priceData[i].endDate =\r\n                currentDateTimeWithTimezone.format('YYYY-MM-DD');\r\n              priceData[i].endTime =\r\n                currentDateTimeWithTimezone.format('HH:mm');\r\n              priceData[i].endDateTime = moment()\r\n                .utc()\r\n                .format('YYYY-MM-DDTHH:mm:ss[Z]');\r\n            }\r\n\r\n            if (isUpdated)\r\n              connectDataWorkflowCallPrice['body']['output'][\r\n                'elastic_updatePriceData_UpdateDailyPurchase_internal'\r\n              ].push(priceData[i]);\r\n          }\r\n          await get_connectData_WorkflowCallPrice();\r\n\r\n          connectDataWorkflowCallPrice['body']['output'][\r\n            'elastic_updatePriceData_UpdateDailyPurchase_internal'\r\n          ] = [];\r\n          connectDataPrice['body']['pagination']['start'] =\r\n            connectDataPrice['body']['pagination']['start'] +\r\n            connectDataPrice['body']['pagination']['limit'];\r\n        } else {\r\n          isDataEmpty = true;\r\n        }\r\n      });\r\n    } while (!isDataEmpty);\r\n\r\n    console.log('Limit reset done');\r\n    res.status(200).send();\r\n  })\r\n  .catch((err) => res.status(500).send(err));",
  "sys__UUID": "27cd2c5c-fd9b-4d43-94d4-0206095a6723",
  "type": "processor"
}

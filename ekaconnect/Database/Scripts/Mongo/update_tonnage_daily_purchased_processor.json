{
  "_id": "update_tonnage_daily_purchased_processor",
  "name": "update_tonnage_daily_purchased_processor",
  "refType": "app",
  "refTypeId": "12325a98-a959-4939-9005-4158d136afcd",
  "snippet": "const appId = '12325a98-a959-4939-9005-4158d136afcd';\r\nconst regionSitesMasterDataObjId = 'ac4bf583-a9a4-446d-b6f9-3c083c3e1030';\r\nconst ticketObjId = 'a26737b3-a5a9-4fe9-b6f7-29218a3bc45a';\r\nconst tonnageLimitObjId = 'c98119db-1f7c-4802-b72a-6678f1ecc0f3';\r\nconst priceObjId = 'ab3fc628-ecbc-43e0-81cb-aa2d5b6e5c40';\r\nconst workflowTaskName =\r\n  'elastic_updateVolumeLimitData_UpdateDailyPurchase_internal';\r\n\r\nvar moment = require('moment');\r\nvar todayDate = moment().utc().format('DD-MM-YYYY');\r\nvar currentDateTime = moment.utc();\r\nvar currentDateInOnlyDateFormat = moment.utc(\r\n  moment().utc().format('DD-MM-YYYY'),\r\n  'DD-MM-YYYY'\r\n);\r\nconsole.log('todayDate:' + todayDate);\r\n\r\nvar connectDataRegionSitesMasterData = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${regionSitesMasterDataObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectDataTickets = {\r\n  method: 'GET',\r\n  url: req.body.propertyList.eka_connect_host + `\/data\/${appId}\/${ticketObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'ticketHandlerBpRefNo',\r\n          operator: 'in',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'allocationDate',\r\n          operator: 'eq',\r\n          value: `${todayDate}`,\r\n        },\r\n        {\r\n          fieldName: 'ticketStatus',\r\n          operator: 'eq',\r\n          value: 'Complete',\r\n        },\r\n        {\r\n          fieldName: 'cropYear',\r\n          operator: 'in',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'location',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'quantity',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'requestType',\r\n          operator: 'nin',\r\n          value: ['Offer for warehoused tickets'],\r\n        },\r\n        {\r\n          fieldName: 'ticketHandlerCode',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'isparentTicket',\r\n          operator: 'ne',\r\n          value: 'Y',\r\n        },\r\n        {\r\n          fieldName: 'pricingOption',\r\n          operator: 'ne',\r\n          value: 'Contract',\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectMetaPrice = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n};\r\nvar connectMetaVolumeLimit = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/meta\/app\/${appId}\/object\/${tonnageLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n    requestid: req.headers['requestid'],\r\n  },\r\n};\r\n\r\nvar connectDataTonnageLimit = {\r\n  method: 'GET',\r\n  url:\r\n    req.body.propertyList.eka_connect_host +\r\n    `\/data\/${appId}\/${tonnageLimitObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'bpRefNo',\r\n          operator: 'in',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'season',\r\n          operator: 'in',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'bpExternalCode',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar elastic_updateVolumeLimitData_UpdateDailyPurchase_internal = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    workflowTaskName: `${workflowTaskName}`,\r\n    task: `${workflowTaskName}`,\r\n    appId: `${appId}`,\r\n    output: {\r\n      elastic_updateVolumeLimitData_UpdateDailyPurchase_internal: [],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\nfunction call_connect(connectRequest) {\r\n  return new Promise(function (resolve, reject) {\r\n    console.log('Request-' + JSON.stringify(connectRequest));\r\n    request(connectRequest, function (err, response, body) {\r\n      \/\/ console.log(\"Response-\" + JSON.stringify(body));\r\n      if (response.statusCode === 200) resolve(body);\r\n      else {\r\n        reject(err || body);\r\n      }\r\n    });\r\n  });\r\n}\r\n\/\/ function get_connectMeta(connectData) {\r\n\/\/   return new Promise(function (resolve, reject) {\r\n\/\/     \/\/ console.log(\"get_connectData Request-\" + JSON.stringify(connectData));\r\n\/\/     request(connectData, function (err, response, body) {\r\n\/\/       \/\/ console.log(\"get_connectData Response-\" + JSON.stringify(body));\r\n\/\/       if (response.statusCode === 200) resolve(body);\r\n\/\/       else {\r\n\/\/         reject(err || body);\r\n\/\/       }\r\n\/\/     });\r\n\/\/   });\r\n\/\/ }\r\n\/\/ function get_connectData_tickets() {\r\n\/\/   return new Promise(function (resolve, reject) {\r\n\/\/     console.log('Ticket Request - ' + connectDataTickets.url);\r\n\/\/     console.log('Ticket Body -' + JSON.stringify(connectDataTickets.body));\r\n\/\/     request(connectDataTickets, function (err, response, body) {\r\n\/\/       \/\/ console.log('Ticket Response - ' + JSON.stringify(body));\r\n\/\/       if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n\/\/         resolve(body); \/\/Success\r\n\/\/       } else {\r\n\/\/         reject(body); \/\/Failure\r\n\/\/       }\r\n\/\/     });\r\n\/\/   });\r\n\/\/ }\r\n\r\n\/\/ function get_connectData_tonnageLimit() {\r\n\/\/   return new Promise(function (resolve, reject) {\r\n\/\/     console.log('TonnageLimit Request - ' + connectDataTonnageLimit.url);\r\n\/\/     console.log(\r\n\/\/       'TonnageLimit Body -' + JSON.stringify(connectDataTonnageLimit.body)\r\n\/\/     );\r\n\/\/     request(connectDataTonnageLimit, function (err, response, body) {\r\n\/\/       \/\/ console.log('TonnageLimit Response - ' + JSON.stringify(body));\r\n\/\/       if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n\/\/         resolve(body); \/\/Success\r\n\/\/       } else {\r\n\/\/         reject(body); \/\/Failure\r\n\/\/       }\r\n\/\/     });\r\n\/\/   });\r\n\/\/ }\r\n\r\n\/\/ function get_connectData_WorkflowCall() {\r\n\/\/   return new Promise(function (resolve, reject) {\r\n\/\/     console.log('WorkflowCall Request - ' + elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.url);\r\n\/\/     console.log(\r\n\/\/       'WorkflowCall Data -' + JSON.stringify(elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.body)\r\n\/\/     );\r\n\/\/     request(elastic_updateVolumeLimitData_UpdateDailyPurchase_internal, function (err, response, body) {\r\n\/\/       \/\/ console.log('WorkflowCall Response - ' + JSON.stringify(body));\r\n\/\/       if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n\/\/         resolve(body); \/\/Success\r\n\/\/       } else {\r\n\/\/         reject(body); \/\/Failure\r\n\/\/       }\r\n\/\/     });\r\n\/\/   });\r\n\/\/ }\r\n\r\nvar connectDataPrice = {\r\n  method: 'GET',\r\n  url: req.body.propertyList.eka_connect_host + `\/data\/${appId}\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'bpRefNo',\r\n          operator: 'in',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'season',\r\n          operator: 'in',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'status',\r\n          operator: 'ne',\r\n          value: 'Expired',\r\n        },\r\n        {\r\n          fieldName: 'startDateTime',\r\n          operator: 'lte',\r\n          value: `${moment().utc().format('YYYY-MM-DDTHH:mm:ss.SSS[Z]')}`,\r\n        },\r\n        {\r\n          fieldName: 'endDateTime',\r\n          operator: 'gte',\r\n          value: `${moment().utc().format('YYYY-MM-DDTHH:mm:ss.SSS[Z]')}`,\r\n        },\r\n        {\r\n          fieldName: 'bpExternalCode',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'pricingOption',\r\n          operator: 'ne',\r\n          value: 'Contract',\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\nvar connectDataPriceExpired = {\r\n  method: 'GET',\r\n  url: req.body.propertyList.eka_connect_host + `\/data\/${appId}\/${priceObjId}`,\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    sort: { priceId: 'desc' },\r\n    filterData: {\r\n      filter: [\r\n        {\r\n          fieldName: 'bpRefNo',\r\n          operator: 'in',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'season',\r\n          operator: 'in',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'product',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'quality',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'site',\r\n          operator: 'exists',\r\n          value: true,\r\n        },\r\n        {\r\n          fieldName: 'startDateTime',\r\n          operator: 'lte',\r\n          value: `${moment().utc().format('YYYY-MM-DDTHH:mm:ss.SSS[Z]')}`,\r\n        },\r\n        {\r\n          fieldName: 'endDateTime',\r\n          operator: 'lte',\r\n          value: `${moment().utc().format('YYYY-MM-DDTHH:mm:ss.SSS[Z]')}`,\r\n        },\r\n        {\r\n          fieldName: 'bpExternalCode',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'region',\r\n          operator: 'inCaseInsensitive',\r\n          value: [],\r\n        },\r\n        {\r\n          fieldName: 'pricingOption',\r\n          operator: 'ne',\r\n          value: 'Contract',\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\/\/ function get_connectData_Price() {\r\n\/\/   return new Promise(function (resolve, reject) {\r\n\/\/     console.log('get_connectData_Price Request - ' + connectDataPrice.url);\r\n\/\/     console.log(\r\n\/\/       'get_connectData_Price Body -' + JSON.stringify(connectDataPrice.body)\r\n\/\/     );\r\n\/\/     request(connectDataPrice, function (err, response, body) {\r\n\/\/       \/\/ console.log('get_connectData_Price Response - ' + JSON.stringify(body));\r\n\/\/       if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n\/\/         resolve(body); \/\/Success\r\n\/\/       } else {\r\n\/\/         reject(body); \/\/Failure\r\n\/\/       }\r\n\/\/     });\r\n\/\/   });\r\n\/\/ }\r\nvar elastic_updatePriceData_UpdateDailyPurchase_internal = {\r\n  method: 'POST',\r\n  url: req.body.propertyList.eka_connect_host + '\/workflow',\r\n  headers: {\r\n    Authorization: req.headers.authorization,\r\n    'X-TenantID': req.headers['x-tenantid'],\r\n  },\r\n  body: {\r\n    workflowTaskName: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    task: 'elastic_updatePriceData_UpdateDailyPurchase_internal',\r\n    appId: `${appId}`,\r\n    output: {\r\n      elastic_updatePriceData_UpdateDailyPurchase_internal: [],\r\n    },\r\n  },\r\n  json: true,\r\n};\r\n\r\n\/\/ function get_connectData_WorkflowCallPrice() {\r\n\/\/   return new Promise(function (resolve, reject) {\r\n\/\/     console.log(\r\n\/\/       'elastic_updatePriceData_UpdateDailyPurchase_internal Request - ' +\r\n\/\/         elastic_updatePriceData_UpdateDailyPurchase_internal.url\r\n\/\/     );\r\n\/\/     console.log(\r\n\/\/       'elastic_updatePriceData_UpdateDailyPurchase_internal Data -' +\r\n\/\/         JSON.stringify(elastic_updatePriceData_UpdateDailyPurchase_internal.body)\r\n\/\/     );\r\n\/\/     request(elastic_updatePriceData_UpdateDailyPurchase_internal, function (err, response, body) {\r\n\/\/       \/\/ console.log('elastic_updatePriceData_UpdateDailyPurchase_internal Response - ' + JSON.stringify(body));\r\n\/\/       if (response.statusCode >= 200 && response.statusCode <= 299) {\r\n\/\/         resolve(body); \/\/Success\r\n\/\/       } else {\r\n\/\/         reject(body); \/\/Failure\r\n\/\/       }\r\n\/\/     });\r\n\/\/   });\r\n\/\/ }\r\n\/\/Get sum of 'valueKey' by grouping 'groups' keys on array data\r\nfunction getSumQuantityByGroupKey(array, groups, valueKey) {\r\n  var map = new Map();\r\n  groups = [].concat(groups);\r\n  return array.reduce((r, o) => {\r\n    groups.reduce((m, k, i, { length }) => {\r\n      var child;\r\n      if (m.has(o[k])) return m.get(o[k]);\r\n      if (i + 1 === length) {\r\n        child = Object.assign(\r\n          ...groups.map((k) => ({\r\n            [k]: o[k],\r\n          })),\r\n          {\r\n            [valueKey]: 0,\r\n          }\r\n        );\r\n        r.push(child);\r\n      } else {\r\n        child = new Map();\r\n      }\r\n      m.set(o[k], child);\r\n      return child;\r\n    }, map)[valueKey] += +o[valueKey];\r\n    return r;\r\n  }, []);\r\n}\r\n\r\nvar ticketDataReceived = req.body.bulkPayLoadData;\r\n\/\/ console.log('TicketDataReceived - ' + JSON.stringify(ticketDataReceived));\r\n\r\nconnectDataRegionSitesMasterData.body.filterData.filter[0].value =\r\n  ticketDataReceived.map((entry) => entry.location).filter((entry) => entry);\r\ncall_connect(connectDataRegionSitesMasterData)\r\n  .then((RegionSitesMasterData) => {\r\n    ticketDataReceived = ticketDataReceived\r\n      .map((ticketEntry) => {\r\n        const container = RegionSitesMasterData.find(\r\n          (regionSitesEntry) =>\r\n            regionSitesEntry.site.toLowerCase() ==\r\n            ticketEntry.location.toLowerCase()\r\n        );\r\n        if (container) ticketEntry.region = container.region;\r\n        return ticketEntry;\r\n      })\r\n      .filter((ticketEntry) => ticketEntry.region);\r\n    if (ticketDataReceived.length > 0) {\r\n      var deletedTicketData = [];\r\n      var isTicketDataDeleted = false;\r\n      var bpRefNoListFiltered = [];\r\n      var bpExternalCodeListFiltered = [];\r\n      var cropYearListFiltered = [];\r\n      var productListFiltered = [];\r\n      var regionListFiltered = [];\r\n      \/\/Filter out any bad ticket records\r\n      for (let i = 0; i < ticketDataReceived.length; i++) {\r\n        if (\r\n          ticketDataReceived[i]['ticketHandlerBpRefNo'] &&\r\n          ticketDataReceived[i]['ticketHandlerCode'] &&\r\n          ticketDataReceived[i]['cropYear'] &&\r\n          ticketDataReceived[i]['product'] &&\r\n          ticketDataReceived[i]['pricingOption'].toLowerCase() != 'contract' &&\r\n          ticketDataReceived[i]['quality'] &&\r\n          ticketDataReceived[i]['location'] &&\r\n          ticketDataReceived[i]['quantity'] &&\r\n          ticketDataReceived[i]['region'] &&\r\n          ticketDataReceived[i]['ticketStatus'] === 'Complete' &&\r\n          ticketDataReceived[i]['allocationDate'] === todayDate\r\n        ) {\r\n          bpRefNoListFiltered.push(\r\n            ticketDataReceived[i]['ticketHandlerBpRefNo']\r\n          );\r\n          bpExternalCodeListFiltered.push(\r\n            ticketDataReceived[i]['ticketHandlerCode']\r\n          );\r\n          cropYearListFiltered.push(ticketDataReceived[i]['cropYear']);\r\n          productListFiltered.push(ticketDataReceived[i]['product']);\r\n          regionListFiltered.push(ticketDataReceived[i]['region']);\r\n\r\n          \/\/To handle usecase when only one ticket present gets deleted. Daily purchased needs to be cleared in Tonnage limit\r\n          if (ticketDataReceived[i]['sys__data__state'] === 'Delete') {\r\n            ticketDataReceived[i]['quantity'] = 0;\r\n            deletedTicketData.push(ticketDataReceived[i]);\r\n            isTicketDataDeleted = true;\r\n          }\r\n        }\r\n      }\r\n      \/\/Get unique bpRefNo list,cropYear list,product list\r\n      var bpRefNoListFilteredUnique = bpRefNoListFiltered.filter(\r\n        (x, i, a) => a.indexOf(x) === i\r\n      );\r\n      var bpExternalCodeListFilteredUnique = bpExternalCodeListFiltered.filter(\r\n        (x, i, a) => a.indexOf(x) === i\r\n      );\r\n      var cropYearListFilteredUnique = cropYearListFiltered.filter(\r\n        (x, i, a) => a.indexOf(x) === i\r\n      );\r\n      var productListFilteredUnique = productListFiltered.filter(\r\n        (x, i, a) => a.indexOf(x) === i\r\n      );\r\n      var regionListFilteredUnique = regionListFiltered.filter(\r\n        (x, i, a) => a.indexOf(x) === i\r\n      );\r\n\r\n      \/\/Add unique bpRefNo list,cropYear list,product list to connectDataTickets\r\n      connectDataTickets.body.filterData.filter[0].value =\r\n        bpRefNoListFilteredUnique;\r\n      connectDataTickets.body.filterData.filter[3].value =\r\n        cropYearListFilteredUnique;\r\n      connectDataTickets.body.filterData.filter[4].value =\r\n        productListFilteredUnique;\r\n      connectDataTickets.body.filterData.filter[9].value =\r\n        bpExternalCodeListFilteredUnique;\r\n\r\n      \/\/Add unique bpRefNo list,cropYear list,product list to connectDataTonnageLimit\r\n      connectDataTonnageLimit.body.filterData.filter[0].value =\r\n        bpRefNoListFilteredUnique;\r\n      connectDataTonnageLimit.body.filterData.filter[1].value =\r\n        cropYearListFilteredUnique;\r\n      connectDataTonnageLimit.body.filterData.filter[2].value =\r\n        productListFilteredUnique;\r\n      connectDataTonnageLimit.body.filterData.filter[5].value =\r\n        bpExternalCodeListFilteredUnique;\r\n      connectDataTonnageLimit.body.filterData.filter[6].value =\r\n        regionListFilteredUnique;\r\n\r\n      connectDataPrice.body.filterData.filter[0].value =\r\n        bpRefNoListFilteredUnique;\r\n      connectDataPrice.body.filterData.filter[1].value =\r\n        cropYearListFilteredUnique;\r\n      connectDataPrice.body.filterData.filter[2].value =\r\n        productListFilteredUnique;\r\n      connectDataPrice.body.filterData.filter[8].value =\r\n        bpExternalCodeListFilteredUnique;\r\n      connectDataPrice.body.filterData.filter[9].value =\r\n        regionListFilteredUnique;\r\n\r\n      connectDataPriceExpired.body.filterData.filter[0].value =\r\n        bpRefNoListFilteredUnique;\r\n      connectDataPriceExpired.body.filterData.filter[1].value =\r\n        cropYearListFilteredUnique;\r\n      connectDataPriceExpired.body.filterData.filter[2].value =\r\n        productListFilteredUnique;\r\n      connectDataPriceExpired.body.filterData.filter[7].value =\r\n        bpExternalCodeListFilteredUnique;\r\n      connectDataPriceExpired.body.filterData.filter[8].value =\r\n        regionListFilteredUnique;\r\n\r\n      Promise.all([\r\n        call_connect(connectDataTickets),\r\n        call_connect(connectDataTonnageLimit),\r\n        call_connect(connectDataPrice),\r\n        call_connect(connectMetaPrice),\r\n        call_connect(connectMetaVolumeLimit),\r\n        call_connect(connectDataPriceExpired),\r\n      ])\r\n        .then(async function (result) {\r\n          var ticketData = result[0]\r\n            .map((ticketEntry) => {\r\n              const container = RegionSitesMasterData.find(\r\n                (regionSitesEntry) =>\r\n                  regionSitesEntry.site.toLowerCase() ==\r\n                  ticketEntry.location.toLowerCase()\r\n              );\r\n              if (container) ticketEntry.region = container.region;\r\n              return ticketEntry;\r\n            })\r\n            .filter((ticketEntry) => ticketEntry.region);\r\n          var priceUniqueFields = JSON.parse(result[3]).uniqueFields;\r\n          priceUniqueFields.push('purchased');\r\n          priceUniqueFields.push('previousDayPurchased');\r\n          priceUniqueFields.push('clientTimezoneOffset');\r\n          priceUniqueFields.push('id');\r\n          priceUniqueFields.push('region');\r\n          priceUniqueFields.push('startDateTime');\r\n          priceUniqueFields.push('pricingOption');\r\n          priceUniqueFields.push('sustainable');\r\n\r\n          var volumeLimitUniqueFields = JSON.parse(result[4]).uniqueFields;\r\n          volumeLimitUniqueFields.push('id');\r\n          volumeLimitUniqueFields.push('dailypurchased');\r\n          volumeLimitUniqueFields.push('limitBreachStatus');\r\n\r\n          \/\/push deleted Tickets with quantity=0\r\n          if (isTicketDataDeleted) {\r\n            deletedTicketData.forEach((deletedTicket) => {\r\n              ticketData.push(deletedTicket);\r\n            });\r\n          }\r\n          \/\/Converting all important ticket fields to lower case to handle case insensitive\r\n          ticketData.forEach(function (item) {\r\n            if (item.ticketHandlerCode)\r\n              item.ticketHandlerCode = item.ticketHandlerCode.toLowerCase();\r\n            if (item.product) item.product = item.product.toLowerCase();\r\n            if (item.region) item.region = item.region.toLowerCase();\r\n            if (item.quality) item.quality = item.quality.toLowerCase();\r\n            if (item.location) item.location = item.location.toLowerCase();\r\n            if (item.pricingOption)\r\n              item.pricingOption = item.pricingOption.toLowerCase();\r\n          });\r\n          ticketData = ticketData.filter((e) => e.pricingOption != 'contract');\r\n          var tonnageLimitData = result[1];\r\n\r\n          \/\/Get sum of quantity by grouping on ['ticketHandlerBpRefNo','ticketHandlerCode','cropYear','product','region','quality','location']\r\n          var sumQuantityTicket = getSumQuantityByGroupKey(\r\n            ticketData,\r\n            [\r\n              'ticketHandlerBpRefNo',\r\n              'ticketHandlerCode',\r\n              'cropYear',\r\n              'product',\r\n              'region',\r\n              'quality',\r\n              'location',\r\n              'pricingOption',\r\n            ],\r\n            'quantity'\r\n          );\r\n          \/\/ console.log('**********************************************************************');\r\n          \/\/ console.log('sumQuantityTicket:' + JSON.stringify(sumQuantityTicket));\r\n          \/\/ console.log('**********************************************************************');\r\n\r\n          \/\/Get sum of quantity by grouping on ['ticketHandlerBpRefNo','ticketHandlerCode','cropYear','product','region','quality'] and add to sumQuantityTicket with 'location'='all'\r\n          const sumQuantityTicketAllLocation = getSumQuantityByGroupKey(\r\n            ticketData,\r\n            [\r\n              'ticketHandlerBpRefNo',\r\n              'ticketHandlerCode',\r\n              'cropYear',\r\n              'product',\r\n              'region',\r\n              'quality',\r\n              'pricingOption',\r\n            ],\r\n            'quantity'\r\n          );\r\n          sumQuantityTicketAllLocation.forEach((sumQuantityAllLocation) => {\r\n            sumQuantityTicket.push({\r\n              ticketHandlerBpRefNo:\r\n                sumQuantityAllLocation['ticketHandlerBpRefNo'],\r\n              ticketHandlerCode: sumQuantityAllLocation['ticketHandlerCode'],\r\n              cropYear: sumQuantityAllLocation['cropYear'],\r\n              product: sumQuantityAllLocation['product'],\r\n              pricingOption: sumQuantityAllLocation['pricingOption'],\r\n              region: sumQuantityAllLocation['region'],\r\n              quality: sumQuantityAllLocation['quality'],\r\n              location: 'all',\r\n              quantity: sumQuantityAllLocation['quantity'],\r\n            });\r\n          });\r\n          \/\/ console.log('**********************************************************************');\r\n          \/\/ console.log('sumQuantityTicketAllLocation:' + JSON.stringify(sumQuantityTicket));\r\n          \/\/ console.log('**********************************************************************');\r\n\r\n          \/\/Get sum of quantity by grouping on ['ticketHandlerBpRefNo','ticketHandlerCode','cropYear','product','region','location'] and add to sumQuantityTicket with 'quality'='all'\r\n          const sumQuantityTicketAllQuality = getSumQuantityByGroupKey(\r\n            ticketData,\r\n            [\r\n              'ticketHandlerBpRefNo',\r\n              'ticketHandlerCode',\r\n              'cropYear',\r\n              'product',\r\n              'region',\r\n              'location',\r\n              'pricingOption',\r\n            ],\r\n            'quantity'\r\n          );\r\n          sumQuantityTicketAllQuality.forEach((sumQuantityAllQuality) => {\r\n            sumQuantityTicket.push({\r\n              ticketHandlerBpRefNo:\r\n                sumQuantityAllQuality['ticketHandlerBpRefNo'],\r\n              ticketHandlerCode: sumQuantityAllQuality['ticketHandlerCode'],\r\n              cropYear: sumQuantityAllQuality['cropYear'],\r\n              product: sumQuantityAllQuality['product'],\r\n              pricingOption: sumQuantityAllQuality['pricingOption'],\r\n              region: sumQuantityAllQuality['region'],\r\n              quality: 'all',\r\n              location: sumQuantityAllQuality['location'],\r\n              quantity: sumQuantityAllQuality['quantity'],\r\n            });\r\n          });\r\n          \/\/ console.log('**********************************************************************');\r\n          \/\/ console.log('sumQuantityTicketAllQuality:' + JSON.stringify(sumQuantityTicket));\r\n          \/\/ console.log('**********************************************************************');\r\n\r\n          \/\/Get sum of quantity by grouping on ['ticketHandlerBpRefNo','ticketHandlerCode','cropYear','region','product'] and add to sumQuantityTicket with 'quality'='all' , 'location'='all'\r\n          const sumQuantityTicketAllQualityLocation = getSumQuantityByGroupKey(\r\n            ticketData,\r\n            [\r\n              'ticketHandlerBpRefNo',\r\n              'ticketHandlerCode',\r\n              'cropYear',\r\n              'product',\r\n              'region',\r\n              'pricingOption',\r\n            ],\r\n            'quantity'\r\n          );\r\n          sumQuantityTicketAllQualityLocation.forEach(\r\n            (sumQuantityAllQualityLocation) => {\r\n              sumQuantityTicket.push({\r\n                ticketHandlerBpRefNo:\r\n                  sumQuantityAllQualityLocation['ticketHandlerBpRefNo'],\r\n                ticketHandlerCode:\r\n                  sumQuantityAllQualityLocation['ticketHandlerCode'],\r\n                cropYear: sumQuantityAllQualityLocation['cropYear'],\r\n                product: sumQuantityAllQualityLocation['product'],\r\n                region: sumQuantityAllQualityLocation['region'],\r\n                pricingOption: sumQuantityAllQualityLocation['pricingOption'],\r\n                quality: 'all',\r\n                location: 'all',\r\n                quantity: sumQuantityAllQualityLocation['quantity'],\r\n              });\r\n            }\r\n          );\r\n          console.log(\r\n            '**********************************************************************'\r\n          );\r\n          console.log(\r\n            'sumQuantityTicketAllQualityLocation:' +\r\n              JSON.stringify(sumQuantityTicket)\r\n          );\r\n          console.log(\r\n            '**********************************************************************'\r\n          );\r\n\r\n          \/\/var isDataEmpty = false;\r\n          var isUpdated = false;\r\n          var sumTicketFilteredByLimitBreachedAllSiteORAllGrade;\r\n          \/\/do {\r\n          \/\/    var tonnageLimitData = await get_connectData_tonnageLimit();\r\n          \/\/if (tonnageLimitData.length !== 0) {\r\n          var sumTicket;\r\n          for (let i = 0; i < tonnageLimitData.length; i++) {\r\n            isUpdated = false;\r\n            sumTicket = sumQuantityTicket.filter(\r\n              (sumTicket) =>\r\n                sumTicket['ticketHandlerBpRefNo'] ===\r\n                  tonnageLimitData[i]['bpRefNo'] &&\r\n                sumTicket['ticketHandlerCode'] ===\r\n                  tonnageLimitData[i]['bpExternalCode'].toLowerCase() &&\r\n                sumTicket['cropYear'] === tonnageLimitData[i]['season'] &&\r\n                sumTicket['product'] ===\r\n                  tonnageLimitData[i]['product'].toLowerCase() &&\r\n                sumTicket['region'] ===\r\n                  tonnageLimitData[i]['region'].toLowerCase() &&\r\n                sumTicket['quality'] ===\r\n                  tonnageLimitData[i]['quality'].toLowerCase() &&\r\n                sumTicket['location'] ===\r\n                  tonnageLimitData[i]['site'].toLowerCase()\r\n            );\r\n            if (sumTicket.length > 0) {\r\n              isUpdated = true;\r\n              sumTicket.forEach((e) => {\r\n                e.quantity =\r\n                  e.quantity +\r\n                  (tonnageLimitData[i]['dailypurchasedByContractOffer']\r\n                    ? tonnageLimitData[i]['dailypurchasedByContractOffer']\r\n                    : 0);\r\n              });\r\n              tonnageLimitData[i]['dailypurchased'] = sumTicket.reduce(\r\n                (n, { quantity }) => n + quantity,\r\n                0\r\n              );\r\n              if (\r\n                tonnageLimitData[i]['dailypurchased'] >\r\n                tonnageLimitData[i]['dailyLimit']\r\n              ) {\r\n                tonnageLimitData[i]['limitBreachStatus'] = 'Y';\r\n                sumTicket.forEach((e) => {\r\n                  e.limitBreachStatus = 'Y';\r\n                });\r\n              } else {\r\n                tonnageLimitData[i]['limitBreachStatus'] = 'N';\r\n              }\r\n            }\r\n\r\n            tonnageLimitData[i]['id'] = tonnageLimitData[i]['_id'];\r\n            \/\/ delete tonnageLimitData[i]['_id'];\r\n            \/\/ delete tonnageLimitData[i]['object'];\r\n            \/\/ delete tonnageLimitData[i]['refTypeId'];\r\n            \/\/ if (tonnageLimitData[i]['sys__createdBy']) delete tonnageLimitData[i]['sys__createdBy'];\r\n            \/\/ if (tonnageLimitData[i]['sys__createdOn']) delete tonnageLimitData[i]['sys__createdOn'];\r\n            \/\/ if (tonnageLimitData[i]['sys__data__state']) delete tonnageLimitData[i]['sys__data__state'];\r\n            \/\/ if (tonnageLimitData[i]['sys__updatedBy']) delete tonnageLimitData[i]['sys__updatedBy'];\r\n            \/\/ if (tonnageLimitData[i]['sys__updatedOn']) delete tonnageLimitData[i]['sys__updatedOn'];\r\n            \/\/ if (tonnageLimitData[i]['sys__UUID']) delete tonnageLimitData[i]['sys__UUID'];\r\n            \/\/ if (tonnageLimitData[i]['sys__version']) delete tonnageLimitData[i]['sys__version'];\r\n            \/\/ if (tonnageLimitData[i]['userId']) delete tonnageLimitData[i]['userId'];\r\n            \/\/ if (isUpdated) {\r\n            \/\/   elastic_updateVolumeLimitData_UpdateDailyPurchase_internal[\r\n            \/\/     'body'\r\n            \/\/   ]['output'][\r\n            \/\/     'elastic_updateVolumeLimitData_UpdateDailyPurchase_internal'\r\n            \/\/   ].push(\r\n            \/\/     volumeLimitUniqueFields.reduce(\r\n            \/\/       (result, item) => ({\r\n            \/\/         ...result,\r\n            \/\/         [item]: tonnageLimitData[i][item],\r\n            \/\/       }),\r\n            \/\/       {}\r\n            \/\/     )\r\n            \/\/   );\r\n            \/\/ }\r\n            elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.push(\r\n              tonnageLimitData[i]\r\n            );\r\n          }\r\n          console.log(\r\n            'sumQuantityTicketAllQualityLocation:' +\r\n              JSON.stringify(sumQuantityTicket)\r\n          );\r\n          var priceData = result[2];\r\n          var priceDataExpired = result[5];\r\n          priceDataExpired = priceDataExpired.filter((priceDataExpired) => {\r\n            if (\r\n              priceData.find(\r\n                (priceDataActive) =>\r\n                  priceDataActive.bpRefNo === priceDataExpired.bpRefNo &&\r\n                  priceDataActive.bpExternalCode.toLowerCase() ===\r\n                    priceDataExpired.bpExternalCode.toLowerCase() &&\r\n                  priceDataActive.season === priceDataExpired.season &&\r\n                  priceDataActive.product.toLowerCase() ===\r\n                    priceDataExpired.product.toLowerCase() &&\r\n                  priceDataActive.region.toLowerCase() ===\r\n                    priceDataExpired.region.toLowerCase() &&\r\n                  priceDataActive.quality.toLowerCase() ===\r\n                    priceDataExpired.quality.toLowerCase() &&\r\n                  priceDataActive.site.toLowerCase() ===\r\n                    priceDataExpired.site.toLowerCase() &&\r\n                  priceDataActive.pricingOption.toLowerCase() ===\r\n                    priceDataExpired.pricingOption.toLowerCase()\r\n              )\r\n            )\r\n              return false;\r\n            else return true;\r\n          });\r\n          priceDataExpired = priceDataExpired.filter((priceDataExpired) => {\r\n            if (\r\n              sumQuantityTicket.find(\r\n                (ticket) =>\r\n                  ticket.ticketHandlerBpRefNo === priceDataExpired.bpRefNo &&\r\n                  ticket.ticketHandlerCode ===\r\n                    priceDataExpired.bpExternalCode.toLowerCase() &&\r\n                  ticket.cropYear === priceDataExpired.season &&\r\n                  ticket.product === priceDataExpired.product.toLowerCase() &&\r\n                  ticket.region === priceDataExpired.region.toLowerCase() &&\r\n                  ticket.quality === priceDataExpired.quality.toLowerCase() &&\r\n                  ticket.location === priceDataExpired.site.toLowerCase()\r\n              )\r\n            )\r\n              return true;\r\n            else return false;\r\n          });\r\n\r\n          priceDataExpired = priceDataExpired.filter(\r\n            (v, i, a) =>\r\n              a.findIndex((v2) =>\r\n                [\r\n                  'bpRefNo',\r\n                  'product',\r\n                  'site',\r\n                  'quality',\r\n                  'season',\r\n                  'bpExternalCode',\r\n                ].every((k) => v2[k] === v[k])\r\n              ) === i\r\n          );\r\n          var offset;\r\n          var currentDateTimeWithTimezone;\r\n          var sumTicketFilterPricingOption;\r\n          if (priceData.length > 0) {\r\n            for (let i = 0; i < priceData.length; i++) {\r\n              isUpdated = false;\r\n              sumTicket = sumQuantityTicket.filter(\r\n                (sumTicket) =>\r\n                  sumTicket['ticketHandlerBpRefNo'] ===\r\n                    priceData[i]['bpRefNo'] &&\r\n                  sumTicket['ticketHandlerCode'] ===\r\n                    priceData[i]['bpExternalCode'].toLowerCase() &&\r\n                  sumTicket['cropYear'] === priceData[i]['season'] &&\r\n                  sumTicket['product'] ===\r\n                    priceData[i]['product'].toLowerCase() &&\r\n                  sumTicket['region'] ===\r\n                    priceData[i]['region'].toLowerCase() &&\r\n                  sumTicket['quality'] ===\r\n                    priceData[i]['quality'].toLowerCase() &&\r\n                  sumTicket['location'] === priceData[i]['site'].toLowerCase()\r\n              );\r\n              if (sumTicket.length > 0) {\r\n                sumTicketFilterPricingOption = sumTicket.find(\r\n                  (entry) =>\r\n                    (entry['pricingOption'] === 'cash sustainable' &&\r\n                      priceData[i]['pricingOption'].toLowerCase() === 'cash' &&\r\n                      priceData[i]['sustainable']) ||\r\n                    (entry['pricingOption'] === 'cash' &&\r\n                      priceData[i]['pricingOption'].toLowerCase() === 'cash' &&\r\n                      !priceData[i]['sustainable']) ||\r\n                    (!['cash sustainable', 'cash'].includes(\r\n                      entry['pricingOption']\r\n                    ) &&\r\n                      entry['pricingOption'] ===\r\n                        priceData[i]['pricingOption'].toLowerCase())\r\n                );\r\n                isUpdated = true;\r\n                priceData[i]['id'] = priceData[i]['_id'];\r\n                priceData[i] = priceUniqueFields.reduce(\r\n                  (result, item) => ({ ...result, [item]: priceData[i][item] }),\r\n                  {}\r\n                );\r\n                \/\/ moment(end).isSameOrAfter(today)\r\n                if (sumTicketFilterPricingOption) {\r\n                  if (\r\n                    moment(\r\n                      moment(\r\n                        priceData[i]['startDateTime'],\r\n                        'YYYY-MM-DDTHH:mm:ssZ'\r\n                      )\r\n                    ).isSameOrBefore(currentDateInOnlyDateFormat)\r\n                  ) {\r\n                    priceData[i]['purchased'] =\r\n                      (typeof priceData[i]['previousDayPurchased'] ===\r\n                        'undefined' ||\r\n                      priceData[i]['previousDayPurchased'] == null ||\r\n                      priceData[i]['previousDayPurchased'] == ''\r\n                        ? 0\r\n                        : priceData[i]['previousDayPurchased']) +\r\n                      sumTicketFilterPricingOption['quantity'];\r\n                  } else {\r\n                    priceData[i]['purchased'] =\r\n                      (typeof priceData[i]['previousDayPurchased'] ===\r\n                        'undefined' ||\r\n                      priceData[i]['previousDayPurchased'] == null ||\r\n                      priceData[i]['previousDayPurchased'] == ''\r\n                        ? 0\r\n                        : priceData[i]['previousDayPurchased']) +\r\n                      ticketData\r\n                        .filter(\r\n                          (o) =>\r\n                            moment.utc(o.sys__updatedOn) >=\r\n                              moment(\r\n                                priceData[i].startDateTime,\r\n                                'YYYY-MM-DDTHH:mm:ssZ'\r\n                              ) &&\r\n                            o.ticketHandlerBpRefNo == priceData[i].bpRefNo &&\r\n                            o.ticketHandlerCode.toLowerCase() ==\r\n                              priceData[i].bpExternalCode.toLowerCase() &&\r\n                            o.product.toLowerCase() ==\r\n                              priceData[i].product.toLowerCase() &&\r\n                            o.region.toLowerCase() ==\r\n                              priceData[i].region.toLowerCase() &&\r\n                            o.quality.toLowerCase() ==\r\n                              priceData[i].quality.toLowerCase() &&\r\n                            o.location.toLowerCase() ==\r\n                              priceData[i].site.toLowerCase() &&\r\n                            o.pricingOption.toLowerCase() ==\r\n                              priceData[i].pricingOption.toLowerCase() &&\r\n                            ((o['pricingOption'] === 'cash sustainable' &&\r\n                              priceData[i]['pricingOption'].toLowerCase() ===\r\n                                'cash' &&\r\n                              priceData[i]['sustainable']) ||\r\n                              (o['pricingOption'] === 'cash' &&\r\n                                priceData[i]['pricingOption'].toLowerCase() ===\r\n                                  'cash' &&\r\n                                !priceData[i]['sustainable']) ||\r\n                              (!['cash sustainable', 'cash'].includes(\r\n                                o['pricingOption']\r\n                              ) &&\r\n                                o['pricingOption'] ===\r\n                                  priceData[i]['pricingOption'].toLowerCase()))\r\n                        )\r\n                        .reduce(\r\n                          (previousValue, currentValue) =>\r\n                            previousValue + currentValue.quantity,\r\n                          0\r\n                        );\r\n                    \/\/ sumTicketFilterPricingOption['quantity'];\r\n                  }\r\n                }\r\n                if (sumTicket[0].limitBreachStatus == 'Y') {\r\n                  offset = priceData[i].clientTimezoneOffset\r\n                    ? priceData[i].clientTimezoneOffset\r\n                    : 0;\r\n                  currentDateTimeWithTimezone = currentDateTime\r\n                    .clone()\r\n                    .subtract(offset, 'minutes');\r\n                  priceData[i].status = 'Expired';\r\n                  priceData[i].endDate =\r\n                    currentDateTimeWithTimezone.format('YYYY-MM-DD');\r\n                  priceData[i].endTime =\r\n                    currentDateTimeWithTimezone.format('HH:mm');\r\n                  priceData[i].endDateTime = moment()\r\n                    .utc()\r\n                    .format('YYYY-MM-DDTHH:mm:ss[Z]');\r\n                }\r\n              } else {\r\n              }\r\n              \/\/ else {\r\n              sumTicket = sumQuantityTicket.find(\r\n                (sumTicket) =>\r\n                  sumTicket.limitBreachStatus == 'Y' &&\r\n                  sumTicket['ticketHandlerBpRefNo'] ===\r\n                    priceData[i]['bpRefNo'] &&\r\n                  sumTicket['ticketHandlerCode'] ===\r\n                    priceData[i]['bpExternalCode'].toLowerCase() &&\r\n                  sumTicket['cropYear'] === priceData[i]['season'] &&\r\n                  sumTicket['product'] ===\r\n                    priceData[i]['product'].toLowerCase() &&\r\n                  sumTicket['region'] ===\r\n                    priceData[i]['region'].toLowerCase() &&\r\n                  (sumTicket['quality'] === 'all' ||\r\n                    sumTicket['quality'] ===\r\n                      priceData[i]['quality'].toLowerCase()) &&\r\n                  (sumTicket['location'] === 'all' ||\r\n                    sumTicket['location'] ===\r\n                      priceData[i]['site'].toLowerCase())\r\n              );\r\n              if (sumTicket) {\r\n                isUpdated = true;\r\n                priceData[i]['id'] = priceData[i]['_id'];\r\n                \/\/ priceData[i] = priceUniqueFields.reduce(\r\n                \/\/   (result, item) => ({ ...result, [item]: priceData[i][item] }),\r\n                \/\/   {}\r\n                \/\/ );\r\n\r\n                offset = priceData[i].clientTimezoneOffset\r\n                  ? priceData[i].clientTimezoneOffset\r\n                  : 0;\r\n                currentDateTimeWithTimezone = currentDateTime\r\n                  .clone()\r\n                  .subtract(offset, 'minutes');\r\n                priceData[i].status = 'Expired';\r\n                priceData[i].endDate =\r\n                  currentDateTimeWithTimezone.format('YYYY-MM-DD');\r\n                priceData[i].endTime =\r\n                  currentDateTimeWithTimezone.format('HH:mm');\r\n                priceData[i].endDateTime = moment()\r\n                  .utc()\r\n                  .format('YYYY-MM-DDTHH:mm:ss[Z]');\r\n              }\r\n              \/\/ }\r\n\r\n              if (isUpdated) {\r\n                elastic_updatePriceData_UpdateDailyPurchase_internal['body'][\r\n                  'output'\r\n                ]['elastic_updatePriceData_UpdateDailyPurchase_internal'].push(\r\n                  priceData[i]\r\n                );\r\n              }\r\n            }\r\n          }\r\n          var isUpdatedExpired = false;\r\n          if (priceDataExpired.length > 0) {\r\n            for (let i = 0; i < priceDataExpired.length; i++) {\r\n              isUpdatedExpired = false;\r\n              sumTicket = sumQuantityTicket.filter(\r\n                (sumTicket) =>\r\n                  sumTicket['ticketHandlerBpRefNo'] ===\r\n                    priceDataExpired[i]['bpRefNo'] &&\r\n                  sumTicket['ticketHandlerCode'] ===\r\n                    priceDataExpired[i]['bpExternalCode'].toLowerCase() &&\r\n                  sumTicket['cropYear'] === priceDataExpired[i]['season'] &&\r\n                  sumTicket['product'] ===\r\n                    priceDataExpired[i]['product'].toLowerCase() &&\r\n                  sumTicket['region'] ===\r\n                    priceDataExpired[i]['region'].toLowerCase() &&\r\n                  sumTicket['quality'] ===\r\n                    priceDataExpired[i]['quality'].toLowerCase() &&\r\n                  sumTicket['location'] ===\r\n                    priceDataExpired[i]['site'].toLowerCase()\r\n              );\r\n              if (sumTicket.length > 0) {\r\n                sumTicketFilterPricingOption = sumTicket.find(\r\n                  (entry) =>\r\n                    (entry['pricingOption'] === 'cash sustainable' &&\r\n                      priceDataExpired[i]['pricingOption'].toLowerCase() ===\r\n                        'cash' &&\r\n                      priceDataExpired[i]['sustainable']) ||\r\n                    (entry['pricingOption'] === 'cash' &&\r\n                      priceDataExpired[i]['pricingOption'].toLowerCase() ===\r\n                        'cash' &&\r\n                      !priceDataExpired[i]['sustainable']) ||\r\n                    (!['cash sustainable', 'cash'].includes(\r\n                      entry['pricingOption']\r\n                    ) &&\r\n                      entry['pricingOption'] ===\r\n                        priceDataExpired[i]['pricingOption'].toLowerCase())\r\n                );\r\n                isUpdatedExpired = true;\r\n                priceDataExpired[i]['id'] = priceDataExpired[i]['_id'];\r\n                \/\/ priceDataExpired[i] = priceUniqueFields.reduce(\r\n                \/\/   (result, item) => ({\r\n                \/\/     ...result,\r\n                \/\/     [item]: priceDataExpired[i][item],\r\n                \/\/   }),\r\n                \/\/   {}\r\n                \/\/ );\r\n\r\n                if (sumTicketFilterPricingOption) {\r\n                  if (\r\n                    moment(\r\n                      moment(\r\n                        priceDataExpired[i]['startDateTime'],\r\n                        'YYYY-MM-DDTHH:mm:ssZ'\r\n                      )\r\n                    ).isSameOrBefore(currentDateInOnlyDateFormat)\r\n                  ) {\r\n                    priceDataExpired[i]['purchased'] =\r\n                      (typeof priceDataExpired[i]['previousDayPurchased'] ===\r\n                        'undefined' ||\r\n                      priceDataExpired[i]['previousDayPurchased'] == null ||\r\n                      priceDataExpired[i]['previousDayPurchased'] == ''\r\n                        ? 0\r\n                        : priceDataExpired[i]['previousDayPurchased']) +\r\n                      sumTicketFilterPricingOption['quantity'];\r\n                  } else {\r\n                    priceDataExpired[i]['purchased'] =\r\n                      (typeof priceDataExpired[i]['previousDayPurchased'] ===\r\n                        'undefined' ||\r\n                      priceDataExpired[i]['previousDayPurchased'] == null ||\r\n                      priceDataExpired[i]['previousDayPurchased'] == ''\r\n                        ? 0\r\n                        : priceDataExpired[i]['previousDayPurchased']) +\r\n                      ticketData\r\n                        .filter(\r\n                          (o) =>\r\n                            moment.utc(o.sys__updatedOn) >=\r\n                              moment(\r\n                                priceDataExpired[i].startDateTime,\r\n                                'YYYY-MM-DDTHH:mm:ssZ'\r\n                              ) &&\r\n                            o.ticketHandlerBpRefNo ==\r\n                              priceDataExpired[i].bpRefNo &&\r\n                            o.ticketHandlerCode.toLowerCase() ==\r\n                              priceDataExpired[\r\n                                i\r\n                              ].bpExternalCode.toLowerCase() &&\r\n                            o.product.toLowerCase() ==\r\n                              priceDataExpired[i].product.toLowerCase() &&\r\n                            o.region.toLowerCase() ==\r\n                              priceDataExpired[i].region.toLowerCase() &&\r\n                            o.quality.toLowerCase() ==\r\n                              priceDataExpired[i].quality.toLowerCase() &&\r\n                            o.location.toLowerCase() ==\r\n                              priceDataExpired[i].site.toLowerCase() &&\r\n                            o.pricingOption.toLowerCase() ==\r\n                              priceDataExpired[i].pricingOption.toLowerCase() &&\r\n                            ((o['pricingOption'] === 'cash sustainable' &&\r\n                              priceDataExpired[i][\r\n                                'pricingOption'\r\n                              ].toLowerCase() === 'cash' &&\r\n                              priceDataExpired[i]['sustainable']) ||\r\n                              (o['pricingOption'] === 'cash' &&\r\n                                priceDataExpired[i][\r\n                                  'pricingOption'\r\n                                ].toLowerCase() === 'cash' &&\r\n                                !priceDataExpired[i]['sustainable']) ||\r\n                              (!['cash sustainable', 'cash'].includes(\r\n                                o['pricingOption']\r\n                              ) &&\r\n                                o['pricingOption'] ===\r\n                                  priceDataExpired[i][\r\n                                    'pricingOption'\r\n                                  ].toLowerCase()))\r\n                        )\r\n                        .reduce(\r\n                          (previousValue, currentValue) =>\r\n                            previousValue + currentValue.quantity,\r\n                          0\r\n                        );\r\n                    \/\/ sumTicketFilterPricingOption['quantity'];\r\n                  }\r\n                }\r\n              }\r\n              if (isUpdatedExpired) {\r\n                elastic_updatePriceData_UpdateDailyPurchase_internal['body'][\r\n                  'output'\r\n                ]['elastic_updatePriceData_UpdateDailyPurchase_internal'].push(\r\n                  priceDataExpired[i]\r\n                );\r\n              }\r\n            }\r\n          }\r\n\r\n          if (\r\n            elastic_updatePriceData_UpdateDailyPurchase_internal.body.output\r\n              .elastic_updatePriceData_UpdateDailyPurchase_internal.length > 0\r\n          )\r\n            call_connect(elastic_updatePriceData_UpdateDailyPurchase_internal);\r\n          if (\r\n            elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.body\r\n              .output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal\r\n              .length > 0\r\n          ) {\r\n            var limitBreachedVolumeLimitdata =\r\n              elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.filter(\r\n                (o) =>\r\n                  o.limitBreachStatus == 'Y' &&\r\n                  (o.site == 'All' || o.quality == 'All')\r\n              );\r\n            limitBreachedVolumeLimitdata.forEach((o) => {\r\n              if (o.site == 'All' && o.quality == 'All')\r\n                elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal\r\n                  .filter(\r\n                    (entry) =>\r\n                      o.bpRefNo === entry.bpRefNo &&\r\n                      o.bpExternalCode.toLowerCase() ===\r\n                        entry.bpExternalCode.toLowerCase() &&\r\n                      o.season === entry.season &&\r\n                      o.product.toLowerCase() === entry.product.toLowerCase() &&\r\n                      o.region.toLowerCase() === entry.region.toLowerCase() &&\r\n                      entry.limitBreachStatus != 'Y'\r\n                  )\r\n                  .forEach((entry) => (entry.limitBreachStatus = 'Y'));\r\n              else if (o.site == 'All')\r\n                elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal\r\n                  .filter(\r\n                    (entry) =>\r\n                      o.bpRefNo === entry.bpRefNo &&\r\n                      o.bpExternalCode.toLowerCase() ===\r\n                        entry.bpExternalCode.toLowerCase() &&\r\n                      o.season === entry.season &&\r\n                      o.product.toLowerCase() === entry.product.toLowerCase() &&\r\n                      o.region.toLowerCase() === entry.region.toLowerCase() &&\r\n                      o.quality.toLowerCase() === entry.quality.toLowerCase() &&\r\n                      entry.limitBreachStatus != 'Y'\r\n                  )\r\n                  .forEach((entry) => (entry.limitBreachStatus = 'Y'));\r\n              else if (o.quality == 'All')\r\n                elastic_updateVolumeLimitData_UpdateDailyPurchase_internal.body.output.elastic_updateVolumeLimitData_UpdateDailyPurchase_internal\r\n                  .filter(\r\n                    (entry) =>\r\n                      o.bpRefNo === entry.bpRefNo &&\r\n                      o.bpExternalCode.toLowerCase() ===\r\n                        entry.bpExternalCode.toLowerCase() &&\r\n                      o.season === entry.season &&\r\n                      o.product.toLowerCase() === entry.product.toLowerCase() &&\r\n                      o.region.toLowerCase() === entry.region.toLowerCase() &&\r\n                      o.site.toLowerCase() === entry.site.toLowerCase() &&\r\n                      entry.limitBreachStatus != 'Y'\r\n                  )\r\n                  .forEach((entry) => (entry.limitBreachStatus = 'Y'));\r\n            });\r\n\r\n            call_connect(\r\n              elastic_updateVolumeLimitData_UpdateDailyPurchase_internal\r\n            );\r\n          }\r\n\r\n          console.log('Limit updated');\r\n          res.status(200).send();\r\n        })\r\n        .catch((err) => {\r\n          console.log('Error', err);\r\n          res.status(500).send(err);\r\n        });\r\n    } else {\r\n      console.log('No Limit updated');\r\n      res.status(200).send();\r\n    }\r\n  })\r\n  .catch((err) => {\r\n    console.log('Error', err);\r\n    res.status(500).send(err);\r\n  });",
  "sys__UUID": "3f5d075b-b640-41d1-a139-ec72b2b78098",
  "type": "processor"
}
